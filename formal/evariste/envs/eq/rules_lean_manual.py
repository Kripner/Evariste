# Copyright (c) 2019-present, Facebook, Inc.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.
#

from typing import Tuple, Union, List, Set, Dict

from evariste.envs.eq.graph import Node, INode
from evariste.envs.eq.graph import ZERO, ONE, TWO, PI, NEG_ONE
from evariste.envs.eq.graph import A, B, C, D, E, F, G, H  # , I, J
from evariste.envs.eq.graph import exp, ln, sqrt, Max, Min
from evariste.envs.eq.graph import sin, cos, tan, asin, acos, atan
from evariste.envs.eq.graph import sinh, cosh, tanh, asinh  # , acosh, atanh
from evariste.envs.eq.lean_utils import reload_lean_theorems


from evariste.envs.eq.rules import (
    LeanRule,
    TRule,
    ARule,
    test_duplicated_rules,
    # test_valid_transform_rules_e_numeric,
    # test_valid_transform_rules_c_numeric,
    # test_valid_assert_rules_numeric,
)


T_RULE_TYPE = Union[Tuple[Node, Node], Tuple[Node, Node, List[Node]]]
A_RULE_TYPE = Union[Node, Tuple[Node, List[Node]]]


def lean_rule(**kwargs) -> LeanRule:
    new_kwargs: Dict = {}
    for k, v in kwargs.items():
        if isinstance(v, Node):
            new_kwargs[k] = v.switch_pow()
        elif isinstance(v, list):
            assert all(isinstance(node, Node) for node in v)
            new_kwargs[k] = [node.switch_pow() for node in v]
        else:
            new_kwargs[k] = v
    return LeanRule(**new_kwargs)


# fmt: off
LEAN_REAL_RULES: List[LeanRule] = [
    lean_rule(
        label="real.tanh_eq_sinh_div_cosh",
        statement="∀ (x : ℝ), real.tanh x = real.sinh x / real.cosh x",
        left=tanh(A),
        right=sinh(A) / cosh(A),
    ),
    lean_rule(
        label="real.le_sqrt'",
        statement="∀ {x y : ℝ}, 0 < x → (x ≤ real.sqrt y ↔ x ^ 2 ≤ y)",
        # implicit_vars=[A, B],
        left=A <= sqrt(B),
        right=A ** 2 <= B,
        hyps=[A > 0],
    ),
    lean_rule(
        label="real.cos_eq_one_iff_of_lt_of_lt",
        statement="∀ {x : ℝ}, -(2 * real.pi) < x → x < 2 * real.pi → (real.cos x = 1 ↔ x = 0)",
        # implicit_vars=[A],
        left=cos(A) == ONE,
        right=A == ZERO,
        hyps=[-(2 * PI) < A, A < 2 * PI],
    ),
    # lean_rule(
    #     label="real.arcsin_eq_arctan",
    #     statement="∀ {x : ℝ}, x ∈ set.Ioo (-1) 1 → real.arcsin x = real.arctan (x / real.sqrt (1 - x ^ 2))",
    #     # implicit_vars=[A],
    #     left=asin(A),
    #     right=atan(A / sqrt(1 - A ** 2)),
    #     hyps=[-1 < A, A < 1],
    # ),
    lean_rule(
        label="real.mul_pos",
        statement="∀ {a b : ℝ}, 0 < a → 0 < b → 0 < a * b",
        # implicit_vars=[A, B],
        node=0 < A * B,
        hyps=[0 < A, 0 < B],
    ),
    lean_rule(
        label="real.arcsin_le_pi_div_two",
        statement="∀ (x : ℝ), real.arcsin x ≤ real.pi / 2",
        node=asin(A) <= PI / 2,
    ),
    lean_rule(
        label="real.sq_cos_pi_div_six",
        statement="real.cos (real.pi / 6) ^ 2 = 3 / 4",
        left=cos(PI / 6) ** 2,
        right=INode(3) / 4,
    ),
    # "∀ (x : ℝ), real.arcsin x ∈ set.Icc (-(real.pi / 2)) (real.pi / 2)"
    # "real.arcsin_mem_Icc": (asin(A) <= PI / 2)  # TODO: fix this ?
    lean_rule(
        label="real.log_neg",
        statement="∀ {x : ℝ}, 0 < x → x < 1 → real.log x < 0",
        # implicit_vars=[A],
        node=ln(A) < 0,
        hyps=[0 < A, A < 1],
    ),
    lean_rule(
        label="real.cos_arccos",
        statement="∀ {x : ℝ}, -1 ≤ x → x ≤ 1 → real.cos (real.arccos x) = x",
        # implicit_vars=[A],
        left=cos(acos(A)),
        right=A,
        hyps=[-1 <= A, A <= 1],
    ),
    lean_rule(label="real.pi_le_four", statement="real.pi ≤ 4", node=(PI <= 4)),
    lean_rule(
        label="real.sqrt_div",
        statement="∀ {x : ℝ}, 0 ≤ x → ∀ (y : ℝ), real.sqrt (x / y) = real.sqrt x / real.sqrt y",
        # implicit_vars=[A],
        left=sqrt(A / B),
        right=sqrt(A) / sqrt(B),
        hyps=[0 <= A],
        # hyp_first=True,
    ),
    lean_rule(
        label="real.sinh_add",
        statement="∀ (x y : ℝ), real.sinh (x + y) = real.sinh x * real.cosh y + real.cosh x * real.sinh y",
        left=sinh(A + B),
        right=sinh(A) * cosh(B) + cosh(A) * sinh(B),
    ),
    lean_rule(
        label="real.sqrt_mul",
        statement="∀ {x : ℝ}, 0 ≤ x → ∀ (y : ℝ), real.sqrt (x * y) = real.sqrt x * real.sqrt y",
        # implicit_vars=[A],
        left=sqrt(A * B),
        right=sqrt(A) * sqrt(B),
        hyps=[0 <= A],
        # hyp_first=True,
    ),
    lean_rule(
        label="real.sin_pi_div_six",
        statement="real.sin (real.pi / 6) = 1 / 2",
        left=sin(PI / 6),
        right=ONE / 2,
    ),
    lean_rule(
        label="real.cos_le_cos_of_nonneg_of_le_pi",
        statement="∀ {x y : ℝ}, 0 ≤ x → y ≤ real.pi → x ≤ y → real.cos y ≤ real.cos x",
        # implicit_vars=[A, B],
        node=cos(B) <= cos(A),
        hyps=[0 <= A, B <= PI, A <= B],
    ),
    lean_rule(
        label="real.cos_two_pi_sub",
        statement="∀ (x : ℝ), real.cos (2 * real.pi - x) = real.cos x",
        left=cos(2 * PI - A),
        right=cos(A),
    ),
    lean_rule(
        label="real.log_pos",
        statement="∀ {x : ℝ}, 1 < x → 0 < real.log x",
        # implicit_vars=[A],
        node=0 < ln(A),
        hyps=[1 < A],
    ),
    # lean_rule(  # POW3
    #     label="real.cos_three_mul",
    #     statement="∀ (x : ℝ), real.cos (3 * x) = 4 * real.cos x ^ 3 - 3 * real.cos x",
    #     left=cos(3 * A),
    #     right=4 * cos(A) ** 3 - 3 * cos(A),
    # ),
    lean_rule(
        label="real.arcsin_inj",
        statement="∀ {x y : ℝ}, -1 ≤ x → x ≤ 1 → -1 ≤ y → y ≤ 1 → (real.arcsin x = real.arcsin y ↔ x = y)",
        # implicit_vars=[A, B],
        left=asin(A) == asin(B),
        right=A == B,
        hyps=[-1 <= A, A <= 1, -1 <= B, B <= 1],
    ),
    lean_rule(
        label="real.abs_le_sqrt",
        statement="∀ {x y : ℝ}, x ^ 2 ≤ y → abs x ≤ real.sqrt y",
        # implicit_vars=[A, B],
        node=abs(A) <= sqrt(B),
        hyps=[A ** 2 <= B],
    ),
    # lean_rule(
    #     label="real.lt_arcsin_iff_sin_lt",
    #     statement="∀ {x y : ℝ}, x ∈ set.Icc (-(real.pi / 2)) (real.pi / 2) → y ∈ set.Icc (-1) 1 → (x < real.arcsin y ↔ real.sin x < y)",
    #     # implicit_vars=[A, B],
    #     left=A < asin(B),
    #     right=sin(A) < B,
    #     hyps=[-(PI / 2) <= A, A <= PI / 2, -1 <= B, B <= 1],
    # ),
    lean_rule(
        label="real.arctan_neg",
        statement="∀ (x : ℝ), real.arctan (-x) = -real.arctan x",
        left=atan(-A),
        right=-atan(A),
    ),
    lean_rule(
        label="real.cos_le_one",
        statement="∀ (x : ℝ), real.cos x ≤ 1",
        node=cos(A) <= 1,
    ),
    lean_rule(
        label="real.arccos_neg",
        statement="∀ (x : ℝ), real.arccos (-x) = real.pi - real.arccos x",
        left=acos(-A),
        right=PI - acos(A),
    ),
    lean_rule(
        label="real.sin_sub_pi_div_two",
        statement="∀ (x : ℝ), real.sin (x - real.pi / 2) = -real.cos x",
        left=sin(A - PI / 2),
        right=-cos(A),
    ),
    lean_rule(
        label="real.sin_add_two_pi",
        statement="∀ (x : ℝ), real.sin (x + 2 * real.pi) = real.sin x",
        left=sin(A + 2 * PI),
        right=sin(A),
    ),
    lean_rule(
        label="real.log_nonneg_iff",
        statement="∀ {x : ℝ}, 0 < x → (0 ≤ real.log x ↔ 1 ≤ x)",
        # implicit_vars=[A],
        left=0 <= ln(A),
        right=1 <= A,
        hyps=[0 < A],
    ),
    lean_rule(
        label="real.neg_sqrt_le_of_sq_le",
        statement="∀ {x y : ℝ}, x ^ 2 ≤ y → -real.sqrt y ≤ x",
        # implicit_vars=[A, B],
        node=-sqrt(B) <= A,
        hyps=[A ** 2 <= B],
    ),
    lean_rule(
        label="real.cos_pi_div_eight",
        statement="real.cos (real.pi / 8) = real.sqrt (2 + real.sqrt 2) / 2",
        left=cos(PI / 8),
        right=sqrt(2 + sqrt(TWO)) / 2,
    ),
    lean_rule(
        label="real.arcsin_sin",
        statement="∀ {x : ℝ}, -(real.pi / 2) ≤ x → x ≤ real.pi / 2 → real.arcsin (real.sin x) = x",
        # implicit_vars=[A],
        left=asin(sin(A)),
        right=A,
        hyps=[-(PI / 2) <= A, A <= PI / 2],
    ),
    lean_rule(
        label="real.arccos_nonneg",
        statement="∀ (x : ℝ), 0 ≤ real.arccos x",
        node=0 <= acos(A),
    ),
    lean_rule(
        label="real.tan_nonpos_of_nonpos_of_neg_pi_div_two_le",
        statement="∀ {x : ℝ}, x ≤ 0 → -(real.pi / 2) ≤ x → real.tan x ≤ 0",
        # implicit_vars=[A],
        node=tan(A) <= 0,
        hyps=[A <= 0, -(PI / 2) <= A],
    ),
    lean_rule(
        label="real.arcsin_eq_pi_div_two",
        statement="∀ {x : ℝ}, real.arcsin x = real.pi / 2 ↔ 1 ≤ x",
        # implicit_vars=[A],
        left=asin(A) == PI / 2,
        right=1 <= A,
    ),
    lean_rule(
        label="real.log_abs",
        statement="∀ (x : ℝ), real.log (abs x) = real.log x",
        left=ln(abs(A)),
        right=ln(A),
    ),
    lean_rule(
        label="real.arcsin_lt_zero",
        statement="∀ {x : ℝ}, real.arcsin x < 0 ↔ x < 0",
        # implicit_vars=[A],
        left=asin(A) < 0,
        right=A < 0,
    ),
    lean_rule(
        label="real.neg_pi_div_two_eq_arcsin",
        statement="∀ {x : ℝ}, -(real.pi / 2) = real.arcsin x ↔ x ≤ -1",
        # implicit_vars=[A],
        left=-(PI / 2) == asin(A),
        right=A <= -1,
    ),
    # lean_rule(  # POW3
    #     label="real.cosh_three_mul",
    #     statement="∀ (x : ℝ), real.cosh (3 * x) = 4 * real.cosh x ^ 3 - 3 * real.cosh x",
    #     left=cosh(3 * A),
    #     right=4 * cosh(A) ** 3 - 3 * cosh(A),
    # ),
    lean_rule(
        label="real.eq_one_of_pos_of_log_eq_zero",
        statement="∀ {x : ℝ}, 0 < x → real.log x = 0 → x = 1",
        # implicit_vars=[A],
        left=A,
        right=ONE,
        hyps=[0 < A, ln(A) == ZERO],
    ),
    lean_rule(
        label="real.one_lt_exp_iff",
        statement="∀ {x : ℝ}, 1 < real.exp x ↔ 0 < x",
        # implicit_vars=[A],
        left=1 < exp(A),
        right=0 < A,
    ),
    lean_rule(
        label="real.tan_inj_of_lt_of_lt_pi_div_two",
        statement="∀ {x y : ℝ}, -(real.pi / 2) < x → x < real.pi / 2 → -(real.pi / 2) < y → y < real.pi / 2 → real.tan x = real.tan y → x = y",
        # implicit_vars=[A, B],
        left=A,
        right=B,
        hyps=[-(PI / 2) < A, A < PI / 2, -(PI / 2) < B, B < PI / 2, tan(A) == tan(B)],
    ),
    lean_rule(
        label="real.exp_log_eq_abs",
        statement="∀ {x : ℝ}, x ≠ 0 → real.exp (real.log x) = abs x",
        # implicit_vars=[A],
        left=exp(ln(A)),
        right=abs(A),
        hyps=[A != ZERO],
    ),
    lean_rule(
        label="real.sqrt_lt",
        statement="∀ {x y : ℝ}, 0 ≤ x → (real.sqrt x < real.sqrt y ↔ x < y)",
        # implicit_vars=[A, B],
        left=sqrt(A) < sqrt(B),
        right=A < B,
        hyps=[0 <= A],
    ),
    lean_rule(
        label="real.cos_sub_two_pi",
        statement="∀ (x : ℝ), real.cos (x - 2 * real.pi) = real.cos x",
        left=cos(A - 2 * PI),
        right=cos(A),
    ),
    lean_rule(
        label="real.sin_neg_of_neg_of_neg_pi_lt",
        statement="∀ {x : ℝ}, x < 0 → -real.pi < x → real.sin x < 0",
        # implicit_vars=[A],
        node=sin(A) < 0,
        hyps=[A < 0, -PI < A],
    ),
    lean_rule(
        label="real.arctan_one",
        statement="real.arctan 1 = real.pi / 4",
        left=atan(ONE),
        right=PI / 4,
    ),
    lean_rule(
        label="real.arcsin_eq_neg_pi_div_two",
        statement="∀ {x : ℝ}, real.arcsin x = -(real.pi / 2) ↔ x ≤ -1",
        # implicit_vars=[A],
        left=asin(A) == -(PI / 2),
        right=A <= -1,
    ),
    lean_rule(label="real.pi_ne_zero", statement="real.pi ≠ 0", node=PI != ZERO),
    lean_rule(
        label="real.sin_two_pi",
        statement="real.sin (2 * real.pi) = 0",
        left=sin(2 * PI),
        right=ZERO,
    ),
    lean_rule(
        label="real.sin_sub_pi",
        statement="∀ (x : ℝ), real.sin (x - real.pi) = -real.sin x",
        left=sin(A - PI),
        right=-sin(A),
    ),
    lean_rule(
        label="real.log_lt_log_iff",
        statement="∀ {x y : ℝ}, 0 < x → 0 < y → (real.log x < real.log y ↔ x < y)",
        # implicit_vars=[A, B],
        left=ln(A) < ln(B),
        right=A < B,
        hyps=[0 < A, 0 < B],
    ),
    lean_rule(
        label="real.cos_pos_of_le_one",
        statement="∀ {x : ℝ}, abs x ≤ 1 → 0 < real.cos x",
        # implicit_vars=[A],
        node=0 < cos(A),
        hyps=[abs(A) <= 1],
    ),
    lean_rule(
        label="real.arccos_eq_pi",
        statement="∀ {x : ℝ}, real.arccos x = real.pi ↔ x ≤ -1",
        # implicit_vars=[A],
        left=acos(A) == PI,
        right=A <= -1,
    ),
    # lean_rule(
    #     label="real.arcsin_eq_of_sin_eq",
    #     statement="∀ {x y : ℝ}, real.sin x = y → x ∈ set.Icc (-(real.pi / 2)) (real.pi / 2) → real.arcsin y = x",
    #     # implicit_vars=[A, B],
    #     left=asin(B),
    #     right=A,
    #     hyps=[sin(A) == B, -(PI / 2) <= A, A <= PI / 2],
    # ),
    # "∀ {x : ℝ}, real.sin x = 0 ↔ real.cos x = 1 ∨ real.cos x = -1"
    # "real.sin_eq_zero_iff_cos_eq":  # TODO?
    lean_rule(
        label="real.arcsin_neg_one",
        statement="real.arcsin (-1) = -(real.pi / 2)",
        left=asin(NEG_ONE),
        right=-(PI / 2),
    ),
    lean_rule(
        label="real.sin_sub_two_pi",
        statement="∀ (x : ℝ), real.sin (x - 2 * real.pi) = real.sin x",
        left=sin(A - 2 * PI),
        right=sin(A),
    ),
    # lean_rule(
    #     label="real.cos_nonneg_of_mem_Icc",
    #     statement="∀ {x : ℝ}, x ∈ set.Icc (-(real.pi / 2)) (real.pi / 2) → 0 ≤ real.cos x",
    #     # implicit_vars=[A],
    #     node=0 <= cos(A),
    #     hyps=[-(PI / 2) <= A, A <= PI / 2],
    # ),
    lean_rule(
        label="real.le_sqrt_of_sq_le",
        statement="∀ {x y : ℝ}, x ^ 2 ≤ y → x ≤ real.sqrt y",
        # implicit_vars=[A, B],
        node=A <= sqrt(B),
        hyps=[A ** 2 <= B],
    ),
    lean_rule(
        label="real.cos_pi_div_four",
        statement="real.cos (real.pi / 4) = real.sqrt 2 / 2",
        left=cos(PI / 4),
        right=sqrt(TWO) / 2,
    ),
    lean_rule(
        label="real.sqrt_mul'",
        statement="∀ (x : ℝ) {y : ℝ}, 0 ≤ y → real.sqrt (x * y) = real.sqrt x * real.sqrt y",
        # implicit_vars=[B],
        left=sqrt(A * B),
        right=sqrt(A) * sqrt(B),
        hyps=[0 <= B],
    ),
    lean_rule(
        label="real.sin_arcsin",
        statement="∀ {x : ℝ}, -1 ≤ x → x ≤ 1 → real.sin (real.arcsin x) = x",
        # implicit_vars=[A],
        left=sin(asin(A)),
        right=A,
        hyps=[-1 <= A, A <= 1],
    ),
    lean_rule(
        label="real.log_lt_log",
        statement="∀ {x y : ℝ}, 0 < x → x < y → real.log x < real.log y",
        # implicit_vars=[A, B],
        node=ln(A) < ln(B),
        hyps=[0 < A, A < B],
    ),
    lean_rule(
        label="real.cos_neg",
        statement="∀ (x : ℝ), real.cos (-x) = real.cos x",
        left=cos(-A),
        right=cos(A),
    ),
    lean_rule(
        label="real.cos_pi_div_two_sub",
        statement="∀ (x : ℝ), real.cos (real.pi / 2 - x) = real.sin x",
        left=cos(PI / 2 - A),
        right=sin(A),
    ),
    lean_rule(
        label="real.log_nonpos",
        statement="∀ {x : ℝ}, 0 ≤ x → x ≤ 1 → real.log x ≤ 0",
        # implicit_vars=[A],
        node=ln(A) <= 0,
        hyps=[0 <= A, A <= 1],
    ),
    lean_rule(
        label="real.sin_sq_add_cos_sq",
        statement="∀ (x : ℝ), real.sin x ^ 2 + real.cos x ^ 2 = 1",
        left=sin(A) ** 2 + cos(A) ** 2,
        right=ONE,
    ),
    lean_rule(
        label="real.exp_le_exp",
        statement="∀ {x y : ℝ}, real.exp x ≤ real.exp y ↔ x ≤ y",
        # implicit_vars=[A, B],
        left=exp(A) <= exp(B),
        right=A <= B,
    ),
    lean_rule(
        label="real.neg_pi_div_two_le_arcsin",
        statement="∀ (x : ℝ), -(real.pi / 2) ≤ real.arcsin x",
        node=-(PI / 2) <= asin(A),
    ),
    lean_rule(
        label="real.cosh_eq",
        statement="∀ (x : ℝ), real.cosh x = (real.exp x + real.exp (-x)) / 2",
        left=cosh(A),
        right=(exp(A) + exp(-A)) / 2,
    ),
    lean_rule(
        label="real.sin_add_pi",
        statement="∀ (x : ℝ), real.sin (x + real.pi) = -real.sin x",
        left=sin(A + PI),
        right=-sin(A),
    ),
    lean_rule(
        label="real.cosh_sub",
        statement="∀ (x y : ℝ), real.cosh (x - y) = real.cosh x * real.cosh y - real.sinh x * real.sinh y",
        left=cosh(A - B),
        right=cosh(A) * cosh(B) - sinh(A) * sinh(B),
    ),
    lean_rule(
        label="real.log_one", statement="real.log 1 = 0", left=ln(ONE), right=ZERO,
    ),
    lean_rule(
        label="real.tan_lt_tan_of_nonneg_of_lt_pi_div_two",
        statement="∀ {x y : ℝ}, 0 ≤ x → y < real.pi / 2 → x < y → real.tan x < real.tan y",
        # implicit_vars=[A, B],
        node=tan(A) < tan(B),
        hyps=[0 <= A, B < PI / 2, A < B],
    ),
    lean_rule(
        label="real.sqrt_le",
        statement="∀ {x y : ℝ}, 0 ≤ y → (real.sqrt x ≤ real.sqrt y ↔ x ≤ y)",
        # implicit_vars=[A, B],
        left=sqrt(A) <= sqrt(B),
        right=A <= B,
        hyps=[0 <= B],
    ),
    lean_rule(
        label="real.exp_lt_one_iff",
        statement="∀ {x : ℝ}, real.exp x < 1 ↔ x < 0",
        # implicit_vars=[A],
        left=exp(A) < 1,
        right=A < 0,
    ),
    lean_rule(
        label="real.sin_eq_sqrt_one_sub_cos_sq",
        statement="∀ {x : ℝ}, 0 ≤ x → x ≤ real.pi → real.sin x = real.sqrt (1 - real.cos x ^ 2)",
        # implicit_vars=[A],
        left=sin(A),
        right=sqrt(1 - cos(A) ** 2),
        hyps=[0 <= A, A <= PI],
    ),
    lean_rule(
        label="real.arcsin_eq_zero_iff",
        statement="∀ {x : ℝ}, real.arcsin x = 0 ↔ x = 0",
        # implicit_vars=[A],
        left=asin(A) == ZERO,
        right=A == ZERO,
    ),
    lean_rule(
        label="real.arcsin_le_neg_pi_div_two",
        statement="∀ {x : ℝ}, real.arcsin x ≤ -(real.pi / 2) ↔ x ≤ -1",
        # implicit_vars=[A],
        left=asin(A) <= -(PI / 2),
        right=A <= -1,
    ),
    lean_rule(
        label="real.tan_neg_of_neg_of_pi_div_two_lt",
        statement="∀ {x : ℝ}, x < 0 → -(real.pi / 2) < x → real.tan x < 0",
        # implicit_vars=[A],
        node=tan(A) < 0,
        hyps=[A < 0, -(PI / 2) < A],
    ),
    lean_rule(
        label="real.tan_mul_cos",
        statement="∀ {x : ℝ}, real.cos x ≠ 0 → real.tan x * real.cos x = real.sin x",
        # implicit_vars=[A],
        left=tan(A) * cos(A),
        right=sin(A),
        hyps=[cos(A) != ZERO],
    ),
    lean_rule(
        label="real.sin_pos_of_pos_of_lt_pi",
        statement="∀ {x : ℝ}, 0 < x → x < real.pi → 0 < real.sin x",
        # implicit_vars=[A],
        node=0 < sin(A),
        hyps=[0 < A, A < PI],
    ),
    lean_rule(
        label="real.sqrt_le_left",
        statement="∀ {x y : ℝ}, 0 ≤ y → (real.sqrt x ≤ y ↔ x ≤ y ^ 2)",
        # implicit_vars=[A, B],
        left=sqrt(A) <= B,
        right=A <= B ** 2,
        hyps=[0 <= B],
    ),
    # lean_rule(
    #     label="real.le_arcsin_iff_sin_le'",
    #     statement="∀ {x y : ℝ}, x ∈ set.Ioc (-(real.pi / 2)) (real.pi / 2) → (x ≤ real.arcsin y ↔ real.sin x ≤ y)",
    #     # implicit_vars=[A, B],
    #     left=A <= asin(B),
    #     right=sin(A) <= B,
    #     hyps=[-(PI / 2) < A, A <= PI / 2],
    # ),
    lean_rule(
        label="real.cos_nonneg_of_neg_pi_div_two_le_of_le",
        statement="∀ {x : ℝ}, -(real.pi / 2) ≤ x → x ≤ real.pi / 2 → 0 ≤ real.cos x",
        # implicit_vars=[A],
        node=0 <= cos(A),
        hyps=[-(PI / 2) <= A, A <= PI / 2],
    ),
    lean_rule(
        label="real.tanh_neg",
        statement="∀ (x : ℝ), real.tanh (-x) = -real.tanh x",
        left=tanh(-A),
        right=-tanh(A),
    ),
    lean_rule(
        label="real.arctan_lt_pi_div_two",
        statement="∀ (x : ℝ), real.arctan x < real.pi / 2",
        node=atan(A) < PI / 2,
    ),
    # "∀ {w₁ w₂ w₃ w₄ p₁ p₂ p₃ p₄ : ℝ}, 0 ≤ w₁ → 0 ≤ w₂ → 0 ≤ w₃ → 0 ≤ w₄ → 0 ≤ p₁ → 0 ≤ p₂ → 0 ≤ p₃ → 0 ≤ p₄ → w₁ + w₂ + w₃ + w₄ = 1 → p₁ ^ w₁ * p₂ ^ w₂ * p₃ ^ w₃ * p₄ ^ w₄ ≤ w₁ * p₁ + w₂ * p₂ + w₃ * p₃ + w₄ * p₄"
    # "real.geom_mean_le_arith_mean4_weighted"  # TODO
    lean_rule(
        label="real.arcsin_eq_pi_div_two_sub_arccos",
        statement="∀ (x : ℝ), real.arcsin x = real.pi / 2 - real.arccos x",
        left=asin(A),
        right=PI / 2 - acos(A),
    ),
    lean_rule(
        label="real.tan_two_mul",
        statement="∀ {x : ℝ}, real.tan (2 * x) = 2 * real.tan x / (1 - real.tan x ^ 2)",
        # implicit_vars=[A],
        left=tan(2 * A),
        right=2 * tan(A) / (1 - tan(A) ** 2),
    ),
    # # "real.sqrt 2 * real.sqrt 2 ^ 3 = real.sqrt 2 * (2 * (real.sqrt 2)⁻¹ + 4 * ((real.sqrt 2)⁻¹ * 2⁻¹))"
    # "tsirelson_inequality.tsirelson_inequality_aux",  # TODO: check
    # (sqrt(TWO) * sqrt(TWO)) ** 3 == sqrt(TWO) * (2 * (ONE / sqrt(TWO)) + 4 * (ONE / sqrt(TWO)) / 2)
    lean_rule(
        label="real.exp_log",
        statement="∀ {x : ℝ}, 0 < x → real.exp (real.log x) = x",
        # implicit_vars=[A],
        left=exp(ln(A)),
        right=A,
        hyps=[0 < A],
    ),
    lean_rule(
        label="real.log_inv",
        statement="∀ (x : ℝ), real.log x⁻¹ = -real.log x",
        left=ln(A ** -1),
        right=-ln(A),
    ),
    lean_rule(
        label="real.log_neg_iff",
        statement="∀ {x : ℝ}, 0 < x → (real.log x < 0 ↔ x < 1)",
        # implicit_vars=[A],
        left=ln(A) < 0,
        right=A < 1,
        hyps=[0 < A],
    ),
    # lean_rule(
    #     label="real.lt_arcsin_iff_sin_lt'",
    #     statement="∀ {x y : ℝ}, x ∈ set.Ico (-(real.pi / 2)) (real.pi / 2) → (x < real.arcsin y ↔ real.sin x < y)",
    #     # implicit_vars=[A, B],
    #     left=A < asin(B),
    #     right=sin(A) < B,
    #     hyps=[-(PI / 2) <= A, A < PI / 2],
    # ),
    # lean_rule(
    #     label="real.arctan_eq_of_tan_eq",
    #     statement="∀ {x y : ℝ}, real.tan x = y → x ∈ set.Ioo (-(real.pi / 2)) (real.pi / 2) → real.arctan y = x",
    #     # implicit_vars=[A, B],
    #     left=atan(B),
    #     right=A,
    #     hyps=[tan(A) == B, -(PI / 2) < A, A < PI / 2],
    # ),
    lean_rule(
        label="real.sin_le_sin_of_le_of_le_pi_div_two",
        statement="∀ {x y : ℝ}, -(real.pi / 2) ≤ x → y ≤ real.pi / 2 → x ≤ y → real.sin x ≤ real.sin y",
        # implicit_vars=[A, B],
        node=sin(A) <= sin(B),
        hyps=[-(PI / 2) <= A, B <= PI / 2, A <= B],
    ),
    lean_rule(
        label="real.arcsin_one",
        statement="real.arcsin 1 = real.pi / 2",
        left=asin(ONE),
        right=PI / 2,
    ),
    lean_rule(
        label="real.cos_add_pi_div_two",
        statement="∀ (x : ℝ), real.cos (x + real.pi / 2) = -real.sin x",
        left=cos(A + PI / 2),
        right=-sin(A),
    ),
    lean_rule(
        label="real.sq_sin_pi_div_three",
        statement="real.sin (real.pi / 3) ^ 2 = 3 / 4",
        left=sin(PI / 3) ** 2,
        right=INode(3) / 4,
    ),
    lean_rule(
        label="real.tan_pi_div_four",
        statement="real.tan (real.pi / 4) = 1",
        left=tan(PI / 4),
        right=ONE,
    ),
    lean_rule(
        label="real.exp_zero", statement="real.exp 0 = 1", left=exp(ZERO), right=ONE,
    ),
    lean_rule(
        label="real.cos_pi_div_six",
        statement="real.cos (real.pi / 6) = real.sqrt 3 / 2",
        left=cos(PI / 6),
        right=sqrt(INode(3)) / 2,
    ),
    lean_rule(
        label="real.tan_eq_sin_div_cos",
        statement="∀ (x : ℝ), real.tan x = real.sin x / real.cos x",
        left=tan(A),
        right=sin(A) / cos(A),
    ),
    lean_rule(
        label="real.sqrt_zero",
        statement="real.sqrt 0 = 0",
        left=sqrt(ZERO),
        right=ZERO,
    ),
    # "∀ {w₁ w₂ p₁ p₂ : ℝ}, 0 ≤ w₁ → 0 ≤ w₂ → 0 ≤ p₁ → 0 ≤ p₂ → w₁ + w₂ = 1 → p₁ ^ w₁ * p₂ ^ w₂ ≤ w₁ * p₁ + w₂ * p₂"
    # "real.geom_mean_le_arith_mean2_weighted": (  # TODO: add pow
    #     A ** B * C ** D <= A * B + C * D,
    #     [0 <= B, 0 <= D, 0 <= A, 0 <= C, B + D == 1],
    # ),
    lean_rule(
        label="real.cosh_sq",
        statement="∀ (x : ℝ), real.cosh x ^ 2 = real.sinh x ^ 2 + 1",
        left=cosh(A) ** 2,
        right=sinh(A) ** 2 + 1,
    ),
    lean_rule(
        label="real.cos_pi_div_thirty_two",
        statement="real.cos (real.pi / 32) = real.sqrt (2 + real.sqrt (2 + real.sqrt (2 + real.sqrt 2))) / 2",
        left=cos(PI / 32),
        right=sqrt(2 + sqrt(2 + sqrt(2 + sqrt(TWO)))) / 2,
    ),
    # lean_rule(
    #     label="real.sin_pos_of_mem_Ioo",
    #     statement="∀ {x : ℝ}, x ∈ set.Ioo 0 real.pi → 0 < real.sin x",
    #     # implicit_vars=[A],
    #     node=0 < sin(A),
    #     hyps=[0 < A, A < PI],
    # ),
    lean_rule(
        label="real.sinh_eq",
        statement="∀ (x : ℝ), real.sinh x = (real.exp x - real.exp (-x)) / 2",
        left=sinh(A),
        right=(exp(A) - exp(-A)) / 2,
    ),
    lean_rule(label="real.cos_one_pos", statement="0 < real.cos 1", node=0 < cos(ONE)),
    # "∀ {x y : ℝ}, real.sqrt x ≤ y ↔ 0 ≤ y ∧ x ≤ y ^ 2"
    # "real.sqrt_le_iff": (sqrt(A) <= B) # TODO
    lean_rule(
        label="real.arcsin_of_le_neg_one",
        statement="∀ {x : ℝ}, x ≤ -1 → real.arcsin x = -(real.pi / 2)",
        # implicit_vars=[A],
        left=asin(A),
        right=-(PI / 2),
        hyps=[A <= -1],
    ),
    lean_rule(label="real.two_pi_pos", statement="0 < 2 * real.pi", node=0 < 2 * PI),
    lean_rule(
        label="real.cos_sq_le_one",
        statement="∀ (x : ℝ), real.cos x ^ 2 ≤ 1",
        node=cos(A) ** 2 <= 1,
    ),
    lean_rule(
        label="real.cos_sub",
        statement="∀ (x y : ℝ), real.cos (x - y) = real.cos x * real.cos y + real.sin x * real.sin y",
        left=cos(A - B),
        right=cos(A) * cos(B) + sin(A) * sin(B),
    ),
    lean_rule(
        label="real.mul_self_sqrt",
        statement="∀ {x : ℝ}, 0 ≤ x → real.sqrt x * real.sqrt x = x",
        # implicit_vars=[A],
        left=sqrt(A) * sqrt(A),
        right=A,
        hyps=[0 <= A],
    ),
    lean_rule(
        label="real.sin_pi_div_sixteen",
        statement="real.sin (real.pi / 16) = real.sqrt (2 - real.sqrt (2 + real.sqrt 2)) / 2",
        left=sin(PI / 16),
        right=sqrt(2 - sqrt(2 + sqrt(TWO))) / 2,
    ),
    lean_rule(
        label="real.cos_pi_div_sixteen",
        statement="real.cos (real.pi / 16) = real.sqrt (2 + real.sqrt (2 + real.sqrt 2)) / 2",
        left=cos(PI / 16),
        right=sqrt(2 + sqrt(2 + sqrt(TWO))) / 2,
    ),
    lean_rule(
        label="real.cos_add_pi",
        statement="∀ (x : ℝ), real.cos (x + real.pi) = -real.cos x",
        left=cos(A + PI),
        right=-cos(A),
    ),
    lean_rule(
        label="real.log_le_log",
        statement="∀ {x y : ℝ}, 0 < x → 0 < y → (real.log x ≤ real.log y ↔ x ≤ y)",
        # implicit_vars=[A, B],
        left=ln(A) <= ln(B),
        right=A <= B,
        hyps=[0 < A, 0 < B],
    ),
    lean_rule(
        label="real.sin_le_one",
        statement="∀ (x : ℝ), real.sin x ≤ 1",
        node=sin(A) <= 1,
    ),
    lean_rule(
        label="real.abs_sin_eq_sqrt_one_sub_cos_sq",
        statement="∀ (x : ℝ), abs (real.sin x) = real.sqrt (1 - real.cos x ^ 2)",
        left=abs(sin(A)),
        right=sqrt(1 - cos(A) ** 2),
    ),
    lean_rule(
        label="real.sin_lt_sin_of_lt_of_le_pi_div_two",
        statement="∀ {x y : ℝ}, -(real.pi / 2) ≤ x → y ≤ real.pi / 2 → x < y → real.sin x < real.sin y",
        # implicit_vars=[A, B],
        node=sin(A) < sin(B),
        hyps=[-(PI / 2) <= A, B <= PI / 2, A < B],
    ),
    lean_rule(
        label="real.exp_add",
        statement="∀ (x y : ℝ), real.exp (x + y) = real.exp x * real.exp y",
        left=exp(A + B),
        right=exp(A) * exp(B),
    ),
    lean_rule(
        label="real.sqrt_ne_zero'",
        statement="∀ {x : ℝ}, real.sqrt x ≠ 0 ↔ 0 < x",
        # implicit_vars=[A],
        left=sqrt(A) != ZERO,
        right=0 < A,
    ),
    lean_rule(
        label="real.arccos_cos",
        statement="∀ {x : ℝ}, 0 ≤ x → x ≤ real.pi → real.arccos (real.cos x) = x",
        # implicit_vars=[A],
        left=acos(cos(A)),
        right=A,
        hyps=[0 <= A, A <= PI],
    ),
    # lean_rule(  # POW4
    #     label="real.cos_bound",
    #     statement="∀ {x : ℝ}, abs x ≤ 1 → abs (real.cos x - (1 - x ^ 2 / 2)) ≤ abs x ^ 4 * (5 / 96)",
    #     implicit_vars=[A],
    #     node=abs(cos(A) - (1 - (A ** 2) / 2)) <= abs(A ** 4) * 5 / 96,
    #     hyps=[abs(A) <= 1],
    # ),
    lean_rule(label="real.two_le_pi", statement="2 ≤ real.pi", node=2 <= PI),
    lean_rule(
        label="real.pi_lt_315", statement="real.pi < 63 / 20", node=PI < INode(63) / 20,
    ),
    lean_rule(
        label="real.sin_pi_div_thirty_two",
        statement="real.sin (real.pi / 32) = real.sqrt (2 - real.sqrt (2 + real.sqrt (2 + real.sqrt 2))) / 2",
        left=sin(PI / 32),
        right=sqrt(2 - sqrt(2 + sqrt(2 + sqrt(TWO)))) / 2,
    ),
    lean_rule(
        label="real.cos_lt_cos_of_nonneg_of_le_pi_div_two",
        statement="∀ {x y : ℝ}, 0 ≤ x → y ≤ real.pi / 2 → x < y → real.cos y < real.cos x",
        # implicit_vars=[A, B],
        node=cos(B) < cos(A),
        hyps=[0 <= A, B <= PI / 2, A < B],
    ),
    lean_rule(
        label="real.log_zero", statement="real.log 0 = 0", left=ln(ZERO), right=ZERO
    ),
    lean_rule(
        label="real.cos_two_mul",
        statement="∀ (x : ℝ), real.cos (2 * x) = 2 * real.cos x ^ 2 - 1",
        left=cos(2 * A),
        right=2 * cos(A) ** 2 - 1,
    ),
    lean_rule(
        label="real.sqrt_nonneg",
        statement="∀ (x : ℝ), 0 ≤ real.sqrt x",
        node=0 <= sqrt(A),
    ),
    lean_rule(
        label="real.arccos_inj",
        statement="∀ {x y : ℝ}, -1 ≤ x → x ≤ 1 → -1 ≤ y → y ≤ 1 → (real.arccos x = real.arccos y ↔ x = y)",
        # implicit_vars=[A, B],
        left=acos(A) == acos(B),
        right=A == B,
        hyps=[-1 <= A, A <= 1, -1 <= B, B <= 1],
    ),
    lean_rule(
        label="real.exp_log_of_neg",
        statement="∀ {x : ℝ}, x < 0 → real.exp (real.log x) = -x",
        # implicit_vars=[A],
        left=exp(ln(A)),
        right=-A,
        hyps=[A < 0],
    ),
    lean_rule(
        label="real.arctan_zero",
        statement="real.arctan 0 = 0",
        left=atan(ZERO),
        right=ZERO,
    ),
    lean_rule(
        label="real.tan_sq_div_one_add_tan_sq",
        statement="∀ {x : ℝ}, real.cos x ≠ 0 → real.tan x ^ 2 / (1 + real.tan x ^ 2) = real.sin x ^ 2",
        # implicit_vars=[A],
        left=tan(A) ** 2 / (1 + tan(A) ** 2),
        right=sin(A) ** 2,
        hyps=[cos(A) != ZERO],
    ),
    lean_rule(
        label="real.cosh_pos", statement="∀ (x : ℝ), 0 < real.cosh x", node=0 < cosh(A),
    ),
    lean_rule(
        label="real.cos_two_pi",
        statement="real.cos (2 * real.pi) = 1",
        left=cos(2 * PI),
        right=ONE,
    ),
    # lean_rule(  # POW3
    #     label="real.sin_gt_sub_cube",
    #     statement="∀ {x : ℝ}, 0 < x → x ≤ 1 → x - x ^ 3 / 4 < real.sin x",
    #     implicit_vars=[A],
    #     node=A - A ** 3 / 4 < sin(A),
    #     hyps=[0 < A, A <= 1],
    # ),
    # lean_rule(
    #     label="real.le_arcsin_iff_sin_le",
    #     statement="∀ {x y : ℝ}, x ∈ set.Icc (-(real.pi / 2)) (real.pi / 2) → y ∈ set.Icc (-1) 1 → (x ≤ real.arcsin y ↔ real.sin x ≤ y)",
    #     # implicit_vars=[A, B],
    #     left=A <= asin(B),
    #     right=sin(A) <= B,
    #     hyps=[-(PI / 2) <= A, A <= PI / 2, -1 <= B, B <= 1],
    # ),
    # "∀ (x : ℝ), real.arsinh (real.sinh x) = x"
    # "real.arsinh_sinh"  # TODO
    lean_rule(
        label="real.cos_sub_pi_div_two",
        statement="∀ (x : ℝ), real.cos (x - real.pi / 2) = real.sin x",
        left=cos(A - PI / 2),
        right=sin(A),
    ),
    lean_rule(
        label="real.sqrt_eq_iff_mul_self_eq",
        statement="∀ {x y : ℝ}, 0 ≤ x → 0 ≤ y → (real.sqrt x = y ↔ y * y = x)",
        # implicit_vars=[A, B],
        left=sqrt(A) == B,
        right=B * B == A,
        hyps=[0 <= A, 0 <= B],
    ),
    lean_rule(
        label="real.sin_pos_of_pos_of_le_one",
        statement="∀ {x : ℝ}, 0 < x → x ≤ 1 → 0 < real.sin x",
        # implicit_vars=[A],
        node=0 < sin(A),
        hyps=[0 < A, A <= 1],
    ),
    lean_rule(
        label="real.cos_pi",
        statement="real.cos real.pi = -1",
        left=cos(PI),
        right=NEG_ONE,
    ),
    lean_rule(
        label="real.add_lt_add_iff_left",
        statement="∀ {a b : ℝ} (c : ℝ), c + a < c + b ↔ a < b",
        # implicit_vars=[A, B],
        left=C + A < C + B,
        right=A < B,
    ),
    lean_rule(
        label="real.exp_ne_zero",
        statement="∀ (x : ℝ), real.exp x ≠ 0",
        node=exp(A) != ZERO,
    ),
    lean_rule(
        label="real.sqrt_eq_zero'",
        statement="∀ {x : ℝ}, real.sqrt x = 0 ↔ x ≤ 0",
        # implicit_vars=[A],
        left=sqrt(A) == ZERO,
        right=A <= 0,
    ),
    lean_rule(
        label="real.arcsin_neg",
        statement="∀ (x : ℝ), real.arcsin (-x) = -real.arcsin x",
        left=asin(-A),
        right=-asin(A),
    ),
    lean_rule(
        label="real.cos_add",
        statement="∀ (x y : ℝ), real.cos (x + y) = real.cos x * real.cos y - real.sin x * real.sin y",
        left=cos(A + B),
        right=cos(A) * cos(B) - sin(A) * sin(B),
    ),
    # lean_rule(
    #     label="real.arcsin_le_iff_le_sin'",
    #     statement="∀ {x y : ℝ}, y ∈ set.Ico (-(real.pi / 2)) (real.pi / 2) → (real.arcsin x ≤ y ↔ x ≤ real.sin y)",
    #     # implicit_vars=[A, B],
    #     left=asin(A) <= B,
    #     right=A <= sin(B),
    #     hyps=[-(PI / 2) <= B, B < PI / 2],
    # ),
    lean_rule(
        label="real.exp_eq_one_iff",
        statement="∀ (x : ℝ), real.exp x = 1 ↔ x = 0",
        left=exp(A) == ONE,
        right=A == ZERO,
    ),
    lean_rule(
        label="real.sqrt_eq_iff_sq_eq",
        statement="∀ {x y : ℝ}, 0 ≤ x → 0 ≤ y → (real.sqrt x = y ↔ y ^ 2 = x)",
        # implicit_vars=[A, B],
        left=sqrt(A) == B,
        right=B ** 2 == A,
        hyps=[0 <= A, 0 <= B],
    ),
    # {"decl_name":"real.log_two_near_10","decl_type":"abs (real.log 2 - 287209 / 414355) ≤ 1 / 10 ^ 10","success":"SUCCESS"}
    # TODO ?
    lean_rule(
        label="real.cos_zero", statement="real.cos 0 = 1", left=cos(ZERO), right=ONE,
    ),
    lean_rule(
        label="real.cos_pi_div_two",
        statement="real.cos (real.pi / 2) = 0",
        left=cos(PI / 2),
        right=ZERO,
    ),
    lean_rule(
        label="real.cos_pi_sub",
        statement="∀ (x : ℝ), real.cos (real.pi - x) = -real.cos x",
        left=cos(PI - A),
        right=-cos(A),
    ),
    lean_rule(
        label="real.tan_pi_div_two",
        statement="real.tan (real.pi / 2) = 0",
        left=tan(PI / 2),
        right=ZERO,
    ),
    lean_rule(
        label="real.arcsin_lt_pi_div_two",
        statement="∀ {x : ℝ}, real.arcsin x < real.pi / 2 ↔ x < 1",
        # implicit_vars=[A],
        left=asin(A) < PI / 2,
        right=A < 1,
    ),
    lean_rule(
        label="real.neg_one_le_sin",
        statement="∀ (x : ℝ), -1 ≤ real.sin x",
        node=-1 <= sin(A),
    ),
    lean_rule(
        label="real.cosh_neg",
        statement="∀ (x : ℝ), real.cosh (-x) = real.cosh x",
        left=cosh(-A),
        right=cosh(A),
    ),
    lean_rule(
        label="real.sinh_two_mul",
        statement="∀ (x : ℝ), real.sinh (2 * x) = 2 * real.sinh x * real.cosh x",
        left=sinh(2 * A),
        right=2 * sinh(A) * cosh(A),
    ),
    # lean_rule(
    #     label="real.arcsin_lt_iff_lt_sin'",
    #     statement="∀ {x y : ℝ}, y ∈ set.Ioc (-(real.pi / 2)) (real.pi / 2) → (real.arcsin x < y ↔ x < real.sin y)",
    #     # implicit_vars=[A, B],
    #     left=asin(A) < B,
    #     right=A < sin(B),
    #     hyps=[-(PI / 2) < B, B <= PI / 2],
    # ),
    lean_rule(
        label="real.arccos_zero",
        statement="real.arccos 0 = real.pi / 2",
        left=acos(ZERO),
        right=PI / 2,
    ),
    lean_rule(
        label="real.tan_neg",
        statement="∀ (x : ℝ), real.tan (-x) = -real.tan x",
        left=tan(-A),
        right=-tan(A),
    ),
    lean_rule(
        label="real.cos_arcsin",
        statement="∀ {x : ℝ}, -1 ≤ x → x ≤ 1 → real.cos (real.arcsin x) = real.sqrt (1 - x ^ 2)",
        # implicit_vars=[A],
        left=cos(asin(A)),
        right=sqrt(1 - A ** 2),
        hyps=[-1 <= A, A <= 1],
    ),
    lean_rule(
        label="real.sin_add",
        statement="∀ (x y : ℝ), real.sin (x + y) = real.sin x * real.cos y + real.cos x * real.sin y",
        left=sin(A + B),
        right=sin(A) * cos(B) + cos(A) * sin(B),
    ),
    lean_rule(
        label="real.tan_add_pi",
        statement="∀ (x : ℝ), real.tan (x + real.pi) = real.tan x",
        left=tan(A + PI),
        right=tan(A),
    ),
    lean_rule(
        label="real.sin_sub",
        statement="∀ (x y : ℝ), real.sin (x - y) = real.sin x * real.cos y - real.cos x * real.sin y",
        left=sin(A - B),
        right=sin(A) * cos(B) - cos(A) * sin(B),
    ),
    lean_rule(
        label="real.sin_pos_of_pos_of_le_two",
        statement="∀ {x : ℝ}, 0 < x → x ≤ 2 → 0 < real.sin x",
        # implicit_vars=[A],
        node=0 < sin(A),
        hyps=[0 < A, A <= 2],
    ),
    lean_rule(
        label="real.sqrt_pos",
        statement="∀ {x : ℝ}, 0 < real.sqrt x ↔ 0 < x",
        # implicit_vars=[A],
        left=0 < sqrt(A),
        right=0 < A,
    ),
    lean_rule(
        label="real.zero_eq_arcsin_iff",
        statement="∀ {x : ℝ}, 0 = real.arcsin x ↔ x = 0",
        # implicit_vars=[A],
        left=ZERO == asin(A),
        right=A == ZERO,
    ),
    lean_rule(
        label="real.sin_sq",
        statement="∀ (x : ℝ), real.sin x ^ 2 = 1 - real.cos x ^ 2",
        left=sin(A) ** 2,
        right=1 - cos(A) ** 2,
    ),
    lean_rule(
        label="real.abs_cos_eq_sqrt_one_sub_sin_sq",
        statement="∀ (x : ℝ), abs (real.cos x) = real.sqrt (1 - real.sin x ^ 2)",
        left=abs(cos(A)),
        right=sqrt(1 - sin(A) ** 2),
    ),
    lean_rule(
        label="real.sinh_zero",
        statement="real.sinh 0 = 0",
        left=sinh(ZERO),
        right=ZERO,
    ),
    lean_rule(
        label="real.cosh_sq_sub_sinh_sq",
        statement="∀ (x : ℝ), real.cosh x ^ 2 - real.sinh x ^ 2 = 1",
        left=cosh(A) ** 2 - sinh(A) ** 2,
        right=ONE,
    ),
    lean_rule(
        label="real.neg_pi_div_two_lt_arctan",
        statement="∀ (x : ℝ), -(real.pi / 2) < real.arctan x",
        node=-(PI / 2) < atan(A),
    ),
    lean_rule(label="real.cos_two_neg", statement="real.cos 2 < 0", node=cos(TWO) < 0),
    lean_rule(
        label="real.sqrt_ne_zero",
        statement="∀ {x : ℝ}, 0 ≤ x → (real.sqrt x ≠ 0 ↔ x ≠ 0)",
        # implicit_vars=[A],
        left=sqrt(A) != ZERO,
        right=A != ZERO,
        hyps=[0 <= A],
    ),
    lean_rule(
        label="real.sin_pi_div_three",
        statement="real.sin (real.pi / 3) = real.sqrt 3 / 2",
        left=sin(PI / 3),
        right=sqrt(INode(3)) / 2,
    ),
    lean_rule(
        label="real.sqrt_mul_self",
        statement="∀ {x : ℝ}, 0 ≤ x → real.sqrt (x * x) = x",
        # implicit_vars=[A],
        left=sqrt(A * A),
        right=A,
        hyps=[0 <= A],
    ),
    lean_rule(
        label="real.exp_neg",
        statement="∀ (x : ℝ), real.exp (-x) = (real.exp x)⁻¹",
        left=exp(-A),
        right=exp(A) ** -1,
    ),
    lean_rule(
        label="real.cos_sq",
        statement="∀ (x : ℝ), real.cos x ^ 2 = 1 / 2 + real.cos (2 * x) / 2",
        left=cos(A) ** 2,
        right=ONE / 2 + cos(2 * A) / 2,
    ),
    lean_rule(
        label="real.sin_pi_div_two",
        statement="real.sin (real.pi / 2) = 1",
        left=sin(PI / 2),
        right=ONE,
    ),
    lean_rule(
        label="real.sin_nonpos_of_nonnpos_of_neg_pi_le",
        statement="∀ {x : ℝ}, x ≤ 0 → -real.pi ≤ x → real.sin x ≤ 0",
        # implicit_vars=[A],
        node=sin(A) <= 0,
        hyps=[A <= 0, -PI <= A],
    ),
    lean_rule(
        label="real.abs_cos_le_one",
        statement="∀ (x : ℝ), abs (real.cos x) ≤ 1",
        node=abs(cos(A)) <= 1,
    ),
    lean_rule(
        label="real.exp_monotone",
        statement="∀ {x y : ℝ}, x ≤ y → real.exp x ≤ real.exp y",
        # implicit_vars=[A, B],
        node=exp(A) <= exp(B),
        hyps=[A <= B],
    ),
    # lean_rule(
    #     label="real.arcsin_sin'",  # redundant with real.arcsin_sin
    #     statement="∀ {x : ℝ}, x ∈ set.Icc (-(real.pi / 2)) (real.pi / 2) → real.arcsin (real.sin x) = x",
    #     implicit_vars=[A],
    #     left=asin(sin(A)),
    #     right=A,
    #     hyps=[-(PI / 2) <= A, A <= PI / 2],
    # ),
    lean_rule(
        label="real.log_nonneg",
        statement="∀ {x : ℝ}, 1 ≤ x → 0 ≤ real.log x",
        # implicit_vars=[A],
        node=0 <= ln(A),
        hyps=[1 <= A],
    ),
    lean_rule(
        label="real.sinh_sub",
        statement="∀ (x y : ℝ), real.sinh (x - y) = real.sinh x * real.cosh y - real.cosh x * real.sinh y",
        left=sinh(A - B),
        right=sinh(A) * cosh(B) - cosh(A) * sinh(B),
    ),
    lean_rule(
        label="real.sinh_neg",
        statement="∀ (x : ℝ), real.sinh (-x) = -real.sinh x",
        left=sinh(-A),
        right=-sinh(A),
    ),
    lean_rule(
        label="real.arccos_eq_pi_div_two",
        statement="∀ {x : ℝ}, real.arccos x = real.pi / 2 ↔ x = 0",
        # implicit_vars=[A],
        left=acos(A) == PI / 2,
        right=A == ZERO,
    ),
    lean_rule(
        label="real.exp_sub",
        statement="∀ (x y : ℝ), real.exp (x - y) = real.exp x / real.exp y",
        left=exp(A - B),
        right=exp(A) / exp(B),
    ),
    # lean_rule(
    #     label="real.arcsin_lt_iff_lt_sin",
    #     statement="∀ {x y : ℝ}, x ∈ set.Icc (-1) 1 → y ∈ set.Icc (-(real.pi / 2)) (real.pi / 2) → (real.arcsin x < y ↔ x < real.sin y)",
    #     # implicit_vars=[A, B],
    #     left=asin(A) < B,
    #     right=A < sin(B),
    #     hyps=[-1 <= A, A <= 1, -(PI / 2) <= B, B <= PI / 2],
    # ),
    lean_rule(
        label="real.lt_sqrt_of_sq_lt",
        statement="∀ {x y : ℝ}, x ^ 2 < y → x < real.sqrt y",
        # implicit_vars=[A, B],
        node=A < sqrt(B),
        hyps=[A ** 2 < B],
    ),
    lean_rule(
        label="real.log_exp",
        statement="∀ (x : ℝ), real.log (real.exp x) = x",
        left=ln(exp(A)),
        right=A,
    ),
    lean_rule(
        label="real.cos_sq_arctan",
        statement="∀ (x : ℝ), real.cos (real.arctan x) ^ 2 = 1 / (1 + x ^ 2)",
        left=cos(atan(A)) ** 2,
        right=ONE / (1 + A ** 2),
    ),
    lean_rule(
        label="real.cosh_add",
        statement="∀ (x y : ℝ), real.cosh (x + y) = real.cosh x * real.cosh y + real.sinh x * real.sinh y",
        left=cosh(A + B),
        right=cosh(A) * cosh(B) + sinh(A) * sinh(B),
    ),
    lean_rule(
        label="real.cos_neg_of_pi_div_two_lt_of_lt",
        statement="∀ {x : ℝ}, real.pi / 2 < x → x < real.pi + real.pi / 2 → real.cos x < 0",
        # implicit_vars=[A],
        node=cos(A) < 0,
        hyps=[PI / 2 < A, A < PI + PI / 2],
    ),
    lean_rule(
        label="real.log_pos_iff",
        statement="∀ {x : ℝ}, 0 < x → (0 < real.log x ↔ 1 < x)",
        # implicit_vars=[A],
        left=0 < ln(A),
        right=1 < A,
        hyps=[0 < A],
    ),
    # lean_rule(  # POW3 / POW4
    #     label="real.sin_bound",
    #     statement="∀ {x : ℝ}, abs x ≤ 1 → abs (real.sin x - (x - x ^ 3 / 6)) ≤ abs x ^ 4 * (5 / 96)",
    #     implicit_vars=[A],
    #     node=abs(sin(A) - (A - A ** 3 / 6)) <= abs(A) ** 4 * 5 / 96,
    #     hyps=[abs(A) <= 1],
    # ),
    lean_rule(
        label="real.arcsin_nonneg",
        statement="∀ {x : ℝ}, 0 ≤ real.arcsin x ↔ 0 ≤ x",
        # implicit_vars=[A],
        left=0 <= asin(A),
        right=0 <= A,
    ),
    lean_rule(
        label="real.sqrt_one", statement="real.sqrt 1 = 1", left=sqrt(ONE), right=ONE,
    ),
    lean_rule(
        label="real.sin_add_pi_div_two",
        statement="∀ (x : ℝ), real.sin (x + real.pi / 2) = real.cos x",
        left=sin(A + PI / 2),
        right=cos(A),
    ),
    lean_rule(
        label="real.sqrt_eq_zero",
        statement="∀ {x : ℝ}, 0 ≤ x → (real.sqrt x = 0 ↔ x = 0)",
        # implicit_vars=[A],
        left=sqrt(A) == ZERO,
        right=A == ZERO,
        hyps=[0 <= A],
    ),
    lean_rule(
        label="real.sin_pi_div_four",
        statement="real.sin (real.pi / 4) = real.sqrt 2 / 2",
        left=sin(PI / 4),
        right=sqrt(TWO) / 2,
    ),
    lean_rule(
        label="real.arcsin_nonpos",
        statement="∀ {x : ℝ}, real.arcsin x ≤ 0 ↔ x ≤ 0",
        # implicit_vars=[A],
        left=asin(A) <= 0,
        right=A <= 0,
    ),
    lean_rule(
        label="real.sqrt_inj",
        statement="∀ {x y : ℝ}, 0 ≤ x → 0 ≤ y → (real.sqrt x = real.sqrt y ↔ x = y)",
        # implicit_vars=[A, B],
        left=sqrt(A) == sqrt(B),
        right=A == B,
        hyps=[0 <= A, 0 <= B],
    ),
    lean_rule(
        label="real.tan_nonneg_of_nonneg_of_le_pi_div_two",
        statement="∀ {x : ℝ}, 0 ≤ x → x ≤ real.pi / 2 → 0 ≤ real.tan x",
        # implicit_vars=[A],
        node=0 <= tan(A),
        hyps=[0 <= A, A <= PI / 2],
    ),
    lean_rule(
        label="real.arccos_neg_one",
        statement="real.arccos (-1) = real.pi",
        left=acos(NEG_ONE),
        right=PI,
    ),
    lean_rule(
        label="real.sin_pi_div_two_sub",
        statement="∀ (x : ℝ), real.sin (real.pi / 2 - x) = real.cos x",
        left=sin(PI / 2 - A),
        right=cos(A),
    ),
    lean_rule(
        label="real.arcsin_zero",
        statement="real.arcsin 0 = 0",
        left=asin(ZERO),
        right=ZERO,
    ),
    lean_rule(
        label="real.pi_div_two_pos", statement="0 < real.pi / 2", node=0 < PI / 2,
    ),
    lean_rule(
        label="real.one_le_exp",
        statement="∀ {x : ℝ}, 0 ≤ x → 1 ≤ real.exp x",
        # implicit_vars=[A],
        node=1 <= exp(A),
        hyps=[0 <= A],
    ),
    # lean_rule(  # POW3
    #     label="real.sinh_three_mul",
    #     statement="∀ (x : ℝ), real.sinh (3 * x) = 4 * real.sinh x ^ 3 + 3 * real.sinh x",
    #     left=sinh(3 * A),
    #     right=4 * sinh(A) ** 3 + 3 * sinh(A),
    # ),
    # lean_rule(
    #     label="real.arcsin_le_iff_le_sin",
    #     statement="∀ {x y : ℝ}, x ∈ set.Icc (-1) 1 → y ∈ set.Icc (-(real.pi / 2)) (real.pi / 2) → (real.arcsin x ≤ y ↔ x ≤ real.sin y)",
    #     # implicit_vars=[A, B],
    #     left=asin(A) <= B,
    #     right=A <= sin(B),
    #     hyps=[-1 <= A, A <= 1, -(PI / 2) <= B, B <= PI / 2],
    # ),
    lean_rule(
        label="real.tan_arctan",
        statement="∀ (x : ℝ), real.tan (real.arctan x) = x",
        left=tan(atan(A)),
        right=A,
    ),
    lean_rule(
        label="real.tan_pi_sub",
        statement="∀ (x : ℝ), real.tan (real.pi - x) = -real.tan x",
        left=tan(PI - A),
        right=-tan(A),
    ),
    lean_rule(
        label="real.sin_pi_sub",
        statement="∀ (x : ℝ), real.sin (real.pi - x) = real.sin x",
        left=sin(PI - A),
        right=sin(A),
    ),
    lean_rule(
        label="real.one_le_exp_iff",
        statement="∀ {x : ℝ}, 1 ≤ real.exp x ↔ 0 ≤ x",
        # implicit_vars=[A],
        left=1 <= exp(A),
        right=0 <= A,
    ),
    lean_rule(
        label="real.sqrt_mul_self_eq_abs",
        statement="∀ (x : ℝ), real.sqrt (x * x) = abs x",
        left=sqrt(A * A),
        right=abs(A),
    ),
    lean_rule(
        label="real.sin_sq_le_one",
        statement="∀ (x : ℝ), real.sin x ^ 2 ≤ 1",
        node=sin(A) ** 2 <= 1,
    ),
    lean_rule(
        label="real.inv_sqrt_one_add_tan_sq",
        statement="∀ {x : ℝ}, 0 < real.cos x → (real.sqrt (1 + real.tan x ^ 2))⁻¹ = real.cos x",
        # implicit_vars=[A],
        left=sqrt(1 + tan(A) ** 2) ** -1,
        right=cos(A),
        hyps=[cos(A) > 0],
    ),
    lean_rule(
        label="real.tan_sub_pi",
        statement="∀ (x : ℝ), real.tan (x - real.pi) = real.tan x",
        left=tan(A - PI),
        right=tan(A),
    ),
    lean_rule(label="real.pi_gt_three", statement="3 < real.pi", node=3 < PI),
    lean_rule(
        label="real.sin_eq_zero_iff_of_lt_of_lt",
        statement="∀ {x : ℝ}, -real.pi < x → x < real.pi → (real.sin x = 0 ↔ x = 0)",
        # implicit_vars=[A],
        left=sin(A) == ZERO,
        right=A == ZERO,
        hyps=[-PI < A, A < PI],
    ),
    lean_rule(
        label="real.sin_two_pi_sub",
        statement="∀ (x : ℝ), real.sin (2 * real.pi - x) = -real.sin x",
        left=sin(2 * PI - A),
        right=-sin(A),
    ),
    lean_rule(
        label="real.log_ne_zero_of_pos_of_ne_one",
        statement="∀ {x : ℝ}, 0 < x → x ≠ 1 → real.log x ≠ 0",
        # implicit_vars=[A],
        node=ln(A) != ZERO,
        hyps=[0 < A, A != ONE],
    ),
    lean_rule(
        label="real.sqrt_le_sqrt",
        statement="∀ {x y : ℝ}, x ≤ y → real.sqrt x ≤ real.sqrt y",
        # implicit_vars=[A, B],
        node=sqrt(A) <= sqrt(B),
        hyps=[A <= B],
    ),
    lean_rule(
        label="real.cosh_add_sinh",
        statement="∀ (x : ℝ), real.cosh x + real.sinh x = real.exp x",
        left=cosh(A) + sinh(A),
        right=exp(A),
    ),
    lean_rule(
        label="real.exp_pos", statement="∀ (x : ℝ), 0 < real.exp x", node=0 < exp(A),
    ),
    # lean_rule(
    #     label="real.cos_pos_of_mem_Ioo",
    #     statement="∀ {x : ℝ}, x ∈ set.Ioo (-(real.pi / 2)) (real.pi / 2) → 0 < real.cos x",
    #     # implicit_vars=[A],
    #     node=0 < cos(A),
    #     hyps=[-(PI / 2) < A, A < PI / 2],
    # ),
    lean_rule(
        label="real.lt_sqrt",
        statement="∀ {x y : ℝ}, 0 ≤ x → 0 ≤ y → (x < real.sqrt y ↔ x ^ 2 < y)",
        # implicit_vars=[A, B],
        left=A < sqrt(B),
        right=A ** 2 < B,
        hyps=[0 <= A, 0 <= B],
    ),
    lean_rule(
        label="real.log_nonpos_iff'",
        statement="∀ {x : ℝ}, 0 ≤ x → (real.log x ≤ 0 ↔ x ≤ 1)",
        # implicit_vars=[A],
        left=ln(A) <= 0,
        right=A <= 1,
        hyps=[0 <= A],
    ),
    lean_rule(
        label="real.log_neg_eq_log",
        statement="∀ (x : ℝ), real.log (-x) = real.log x",
        left=ln(-A),
        right=ln(A),
    ),
    lean_rule(
        label="real.log_nonpos_iff",
        statement="∀ {x : ℝ}, 0 < x → (real.log x ≤ 0 ↔ x ≤ 1)",
        # implicit_vars=[A],
        left=ln(A) <= 0,
        right=A <= 1,
        hyps=[0 < A],
    ),
    lean_rule(
        label="real.cos_eq_sqrt_one_sub_sin_sq",
        statement="∀ {x : ℝ}, -(real.pi / 2) ≤ x → x ≤ real.pi / 2 → real.cos x = real.sqrt (1 - real.sin x ^ 2)",
        # implicit_vars=[A],
        left=cos(A),
        right=sqrt(1 - sin(A) ** 2),
        hyps=[-(PI / 2) <= A, A <= PI / 2],
    ),
    lean_rule(
        label="real.abs_sin_le_one",
        statement="∀ (x : ℝ), abs (real.sin x) ≤ 1",
        node=abs(sin(A)) <= 1,
    ),
    lean_rule(
        label="real.exp_lt_exp",
        statement="∀ {x y : ℝ}, real.exp x < real.exp y ↔ x < y",
        # implicit_vars=[A, B],
        left=exp(A) < exp(B),
        right=A < B,
    ),
    # lean_rule(
    #     label="real.arcsin_eq_iff_eq_sin",
    #     statement="∀ {x y : ℝ}, y ∈ set.Ioo (-(real.pi / 2)) (real.pi / 2) → (real.arcsin x = y ↔ x = real.sin y)",
    #     # implicit_vars=[A, B],
    #     left=asin(A) == B,
    #     right=A == sin(B),
    #     hyps=[-(PI / 2) < B, B < PI / 2],
    # ),
    lean_rule(
        label="real.cos_sub_pi",
        statement="∀ (x : ℝ), real.cos (x - real.pi) = -real.cos x",
        left=cos(A - PI),
        right=-cos(A),
    ),
    lean_rule(
        label="real.one_le_pi_div_two", statement="1 ≤ real.pi / 2", node=1 <= PI / 2,
    ),
    # lean_rule(
    #     label="real.sin_arcsin'",  # redundant with real.sin_arcsin
    #     statement="∀ {x : ℝ}, x ∈ set.Icc (-1) 1 → real.sin (real.arcsin x) = x",
    #     implicit_vars=[A],
    #     left=sin(asin(A)),
    #     right=A,
    #     hyps=[-1 <= A, A <= 1],
    # ),
    # "∀ {x y : ℝ}, x ^ 2 < y ↔ -real.sqrt y < x ∧ x < real.sqrt y"
    # "real.sq_lt": # TODO
    lean_rule(
        label="real.div_sqrt",
        statement="∀ {x : ℝ}, x / real.sqrt x = real.sqrt x",
        # implicit_vars=[A],
        left=A / sqrt(A),
        right=sqrt(A),
    ),
    lean_rule(
        label="real.cosh_zero", statement="real.cosh 0 = 1", left=cosh(ZERO), right=ONE,
    ),
    lean_rule(
        label="real.exp_eq_exp",
        statement="∀ {x y : ℝ}, real.exp x = real.exp y ↔ x = y",
        # implicit_vars=[A, B],
        left=exp(A) == exp(B),
        right=A == B,
    ),
    lean_rule(
        label="real.neg_pi_div_two_lt_arcsin",
        statement="∀ {x : ℝ}, -(real.pi / 2) < real.arcsin x ↔ -1 < x",
        # implicit_vars=[A],
        left=-(PI / 2) < asin(A),
        right=-1 < A,
    ),
    lean_rule(
        label="real.cos_lt_cos_of_nonneg_of_le_pi",
        statement="∀ {x y : ℝ}, 0 ≤ x → y ≤ real.pi → x < y → real.cos y < real.cos x",
        # implicit_vars=[A, B],
        node=cos(B) < cos(A),
        hyps=[0 <= A, B <= PI, A < B],
    ),
    lean_rule(label="real.zero_lt_one", statement="0 < 1", node=ZERO < ONE),
    lean_rule(
        label="real.sinh_add_cosh",
        statement="∀ (x : ℝ), real.sinh x + real.cosh x = real.exp x",
        left=sinh(A) + cosh(A),
        right=exp(A),
    ),
    lean_rule(
        label="real.cos_add_two_pi",
        statement="∀ (x : ℝ), real.cos (x + 2 * real.pi) = real.cos x",
        left=cos(A + 2 * PI),
        right=cos(A),
    ),
    lean_rule(
        label="real.cos_arctan",
        statement="∀ (x : ℝ), real.cos (real.arctan x) = 1 / real.sqrt (1 + x ^ 2)",
        left=cos(atan(A)),
        right=ONE / sqrt(1 + A ** 2),
    ),
    lean_rule(
        label="real.log_mul",
        statement="∀ {x y : ℝ}, x ≠ 0 → y ≠ 0 → real.log (x * y) = real.log x + real.log y",
        # implicit_vars=[A, B],
        left=ln(A * B),
        right=ln(A) + ln(B),
        hyps=[A != ZERO, B != ZERO],
    ),
    # # "∀ (x y : ℝ), real.exp (x * y) = real.exp x ^ y"  # TODO: pow
    # "real.exp_mul": (exp(A * B) == exp(A) ** B),
    lean_rule(
        label="real.cos_sq'",
        statement="∀ (x : ℝ), real.cos x ^ 2 = 1 - real.sin x ^ 2",
        left=cos(A) ** 2,
        right=1 - sin(A) ** 2,
    ),
    lean_rule(
        label="real.sqrt_inv",
        statement="∀ (x : ℝ), real.sqrt x⁻¹ = (real.sqrt x)⁻¹",
        left=sqrt(A ** -1),
        right=sqrt(A) ** -1,
    ),
    lean_rule(
        label="real.sin_zero", statement="real.sin 0 = 0", left=sin(ZERO), right=ZERO,
    ),
    lean_rule(
        label="real.tan_zero", statement="real.tan 0 = 0", left=tan(ZERO), right=ZERO,
    ),
    lean_rule(
        label="real.sin_neg",
        statement="∀ (x : ℝ), real.sin (-x) = -real.sin x",
        left=sin(-A),
        right=-sin(A),
    ),
    lean_rule(
        label="real.pi_div_two_le_arcsin",
        statement="∀ {x : ℝ}, real.pi / 2 ≤ real.arcsin x ↔ 1 ≤ x",
        # implicit_vars=[A],
        left=PI / 2 <= asin(A),
        right=1 <= A,
    ),
    lean_rule(
        label="real.cos_one_le",
        statement="real.cos 1 ≤ 2 / 3",
        node=cos(ONE) <= INode(2) / 3,
    ),
    lean_rule(
        label="real.exp_le_one_iff",
        statement="∀ {x : ℝ}, real.exp x ≤ 1 ↔ x ≤ 0",
        # implicit_vars=[A],
        left=exp(A) <= 1,
        right=A <= 0,
    ),
    lean_rule(
        label="real.cos_add_cos",
        statement="∀ (x y : ℝ), real.cos x + real.cos y = 2 * real.cos ((x + y) / 2) * real.cos ((x - y) / 2)",
        left=cos(A) + cos(B),
        right=2 * cos((A + B) / 2) * cos((A - B) / 2),
    ),
    lean_rule(label="real.pi_pos", statement="0 < real.pi", node=0 < PI),
    lean_rule(
        label="real.tan_div_sqrt_one_add_tan_sq",
        statement="∀ {x : ℝ}, 0 < real.cos x → real.tan x / real.sqrt (1 + real.tan x ^ 2) = real.sin x",
        # implicit_vars=[A],
        left=tan(A) / sqrt(1 + tan(A) ** 2),
        right=sin(A),
        hyps=[0 < cos(A)],
    ),
    lean_rule(
        label="real.sqrt_sq",
        statement="∀ {x : ℝ}, 0 ≤ x → real.sqrt (x ^ 2) = x",
        # implicit_vars=[A],
        left=sqrt(A ** 2),
        right=A,
        hyps=[0 <= A],
    ),
    lean_rule(
        label="real.sin_pi_div_eight",
        statement="real.sin (real.pi / 8) = real.sqrt (2 - real.sqrt 2) / 2",
        left=sin(PI / 8),
        right=sqrt(2 - sqrt(TWO)) / 2,
    ),
    lean_rule(
        label="real.tan_lt_tan_of_lt_of_lt_pi_div_two",
        statement="∀ {x y : ℝ}, -(real.pi / 2) < x → y < real.pi / 2 → x < y → real.tan x < real.tan y",
        # implicit_vars=[A, B],
        node=tan(A) < tan(B),
        hyps=[-(PI / 2) < A, B < PI / 2, A < B],
    ),
    lean_rule(
        label="real.cos_nonpos_of_pi_div_two_le_of_le",
        statement="∀ {x : ℝ}, real.pi / 2 ≤ x → x ≤ real.pi + real.pi / 2 → real.cos x ≤ 0",
        # implicit_vars=[A],
        node=cos(A) <= 0,
        hyps=[PI / 2 <= A, A <= PI + PI / 2],
    ),
    lean_rule(
        label="real.arctan_tan",
        statement="∀ {x : ℝ}, -(real.pi / 2) < x → x < real.pi / 2 → real.arctan (real.tan x) = x",
        # implicit_vars=[A],
        left=atan(tan(A)),
        right=A,
        hyps=[-(PI / 2) < A, A < PI / 2],
    ),
    lean_rule(
        label="real.cos_sq_add_sin_sq",
        statement="∀ (x : ℝ), real.cos x ^ 2 + real.sin x ^ 2 = 1",
        left=cos(A) ** 2 + sin(A) ** 2,
        right=ONE,
    ),
    # lean_rule(  # POW3
    #     label="real.sin_three_mul",
    #     statement="∀ (x : ℝ), real.sin (3 * x) = 3 * real.sin x - 4 * real.sin x ^ 3",
    #     left=sin(3 * A),
    #     right=3 * sin(A) - 4 * sin(A) ** 3,
    # ),
    lean_rule(
        label="real.cos_arctan_pos",
        statement="∀ (x : ℝ), 0 < real.cos (real.arctan x)",
        node=0 < cos(atan(A)),
    ),
    lean_rule(
        label="real.arcsin_of_one_le",
        statement="∀ {x : ℝ}, 1 ≤ x → real.arcsin x = real.pi / 2",
        # implicit_vars=[A],
        left=asin(A),
        right=PI / 2,
        hyps=[1 <= A],
    ),
    lean_rule(
        label="real.cos_pi_div_three",
        statement="real.cos (real.pi / 3) = 1 / 2",
        left=cos(PI / 3),
        right=ONE / 2,
    ),
    lean_rule(
        label="real.sin_lt",
        statement="∀ {x : ℝ}, 0 < x → real.sin x < x",
        # implicit_vars=[A],
        node=sin(A) < A,
        hyps=[0 < A],
    ),
    lean_rule(
        label="real.le_sqrt",
        statement="∀ {x y : ℝ}, 0 ≤ x → 0 ≤ y → (x ≤ real.sqrt y ↔ x ^ 2 ≤ y)",
        # implicit_vars=[A, B],
        left=A <= sqrt(B),
        right=A ** 2 <= B,
        hyps=[0 <= A, 0 <= B],
    ),
    lean_rule(
        label="real.sin_sub_sin",
        statement="∀ (x y : ℝ), real.sin x - real.sin y = 2 * real.sin ((x - y) / 2) * real.cos ((x + y) / 2)",
        left=sin(A) - sin(B),
        right=2 * sin((A - B) / 2) * cos((A + B) / 2),
    ),
    lean_rule(
        label="real.log_div",
        statement="∀ {x y : ℝ}, x ≠ 0 → y ≠ 0 → real.log (x / y) = real.log x - real.log y",
        # implicit_vars=[A, B],
        left=ln(A / B),
        right=ln(A) - ln(B),
        hyps=[A != ZERO, B != ZERO],
    ),
    lean_rule(
        label="real.sq_sqrt",
        statement="∀ {x : ℝ}, 0 ≤ x → real.sqrt x ^ 2 = x",
        # implicit_vars=[A],
        left=sqrt(A) ** 2,
        right=A,
        hyps=[0 <= A],
    ),
    # lean_rule(  # TODO: not found in my mathlib??
    #     label="real.sqrt_one_add_sinh_sq",
    #     statement="∀ (x : ℝ), real.sqrt (1 + real.sinh x ^ 2) = real.cosh x",
    #     left=sqrt(1 + sinh(A) ** 2),
    #     right=cosh(A),
    # ),
    # "∀ {x y : ℝ}, 0 ≤ y → (x ^ 2 ≤ y ↔ -real.sqrt y ≤ x ∧ x ≤ real.sqrt y)"
    # "real.sq_le": # TODO
    lean_rule(
        label="real.inv_one_add_tan_sq",
        statement="∀ {x : ℝ}, real.cos x ≠ 0 → (1 + real.tan x ^ 2)⁻¹ = real.cos x ^ 2",
        # implicit_vars=[A],
        left=(1 + tan(A) ** 2) ** -1,
        right=cos(A) ** 2,
        hyps=[cos(A) != ZERO],
    ),
    lean_rule(
        label="real.arcsin_pos",
        statement="∀ {x : ℝ}, 0 < real.arcsin x ↔ 0 < x",
        # implicit_vars=[A],
        left=0 < asin(A),
        right=0 < A,
    ),
    lean_rule(
        label="real.arccos_le_pi",
        statement="∀ (x : ℝ), real.arccos x ≤ real.pi",
        node=acos(A) <= PI,
    ),
    lean_rule(
        label="real.sin_arctan",
        statement="∀ (x : ℝ), real.sin (real.arctan x) = x / real.sqrt (1 + x ^ 2)",
        left=sin(atan(A)),
        right=A / sqrt(1 + A ** 2),
    ),
    lean_rule(
        label="real.sin_nonneg_of_nonneg_of_le_pi",
        statement="∀ {x : ℝ}, 0 ≤ x → x ≤ real.pi → 0 ≤ real.sin x",
        # implicit_vars=[A],
        node=0 <= sin(A),
        hyps=[0 <= A, A <= PI],
    ),
    lean_rule(
        label="real.cos_arcsin_nonneg",
        statement="∀ (x : ℝ), 0 ≤ real.cos (real.arcsin x)",
        node=0 <= cos(asin(A)),
    ),
    lean_rule(
        label="real.cos_sub_cos",
        statement="∀ (x y : ℝ), real.cos x - real.cos y = (-2) * real.sin ((x + y) / 2) * real.sin ((x - y) / 2)",
        left=cos(A) - cos(B),
        right=-2 * sin((A + B) / 2) * sin((A - B) / 2),
    ),
    lean_rule(
        label="real.sin_two_mul",
        statement="∀ (x : ℝ), real.sin (2 * x) = 2 * real.sin x * real.cos x",
        left=sin(2 * A),
        right=2 * sin(A) * cos(A),
    ),
    lean_rule(
        label="real.sinh_sq",
        statement="∀ (x : ℝ), real.sinh x ^ 2 = real.cosh x ^ 2 - 1",
        left=sinh(A) ** 2,
        right=cosh(A) ** 2 - 1,
    ),
    lean_rule(
        label="real.add_one_le_exp_of_nonneg",
        statement="∀ {x : ℝ}, 0 ≤ x → x + 1 ≤ real.exp x",
        # implicit_vars=[A],
        node=A + 1 <= exp(A),
        hyps=[0 <= A],
    ),
    lean_rule(
        label="real.sqrt_sq_eq_abs",
        statement="∀ (x : ℝ), real.sqrt (x ^ 2) = abs x",
        left=sqrt(A ** 2),
        right=abs(A),
    ),
    lean_rule(
        label="real.tan_pos_of_pos_of_lt_pi_div_two",
        statement="∀ {x : ℝ}, 0 < x → x < real.pi / 2 → 0 < real.tan x",
        # implicit_vars=[A],
        node=0 < tan(A),
        hyps=[0 < A, A < PI / 2],
    ),
    lean_rule(
        label="real.arccos_one",
        statement="real.arccos 1 = 0",
        left=acos(ONE),
        right=ZERO,
    ),
    lean_rule(
        label="real.arccos_eq_pi_div_two_sub_arcsin",
        statement="∀ (x : ℝ), real.arccos x = real.pi / 2 - real.arcsin x",
        left=acos(A),
        right=PI / 2 - asin(A),
    ),
    lean_rule(
        label="real.sinh_arsinh",
        statement="∀ (x : ℝ), real.sinh (real.arsinh x) = x",
        left=sinh(asinh(A)),
        right=A,
    ),
    lean_rule(
        label="real.neg_one_le_cos",
        statement="∀ (x : ℝ), -1 ≤ real.cos x",
        node=-1 <= cos(A),
    ),
    lean_rule(
        label="real.sqrt_eq_zero_of_nonpos",
        statement="∀ {x : ℝ}, x ≤ 0 → real.sqrt x = 0",
        # implicit_vars=[A],
        left=sqrt(A),
        right=ZERO,
        hyps=[A <= 0],
    ),
    lean_rule(
        label="real.pi_div_two_eq_arcsin",
        statement="∀ {x : ℝ}, real.pi / 2 = real.arcsin x ↔ 1 ≤ x",
        # implicit_vars=[A],
        left=PI / 2 == asin(A),
        right=1 <= A,
    ),
    # {"decl_name":"real.geom_mean_le_arith_mean3_weighted","decl_type":"∀ {w₁ w₂ w₃ p₁ p₂ p₃ : ℝ}, 0 ≤ w₁ → 0 ≤ w₂ → 0 ≤ w₃ → 0 ≤ p₁ → 0 ≤ p₂ → 0 ≤ p₃ → w₁ + w₂ + w₃ = 1 → p₁ ^ w₁ * p₂ ^ w₂ * p₃ ^ w₃ ≤ w₁ * p₁ + w₂ * p₂ + w₃ * p₃","success":"SUCCESS"}
    # TODO
    lean_rule(
        label="real.cosh_two_mul",
        statement="∀ (x : ℝ), real.cosh (2 * x) = real.cosh x ^ 2 + real.sinh x ^ 2",
        left=cosh(2 * A),
        right=cosh(A) ** 2 + sinh(A) ** 2,
    ),
    lean_rule(
        label="real.abs_exp",
        statement="∀ (x : ℝ), abs (real.exp x) = real.exp x",
        left=abs(exp(A)),
        right=exp(A),
    ),
    lean_rule(
        label="real.arctan_eq_arcsin",
        statement="∀ (x : ℝ), real.arctan x = real.arcsin (x / real.sqrt (1 + x ^ 2))",
        left=atan(A),
        right=asin(A / sqrt(1 + A ** 2)),
    ),
    lean_rule(
        label="real.arccos_eq_zero",
        statement="∀ {x : ℝ}, real.arccos x = 0 ↔ 1 ≤ x",
        # implicit_vars=[A],
        left=acos(A) == ZERO,
        right=1 <= A,
    ),
    lean_rule(
        label="real.neg_sqrt_lt_of_sq_lt",
        statement="∀ {x y : ℝ}, x ^ 2 < y → -real.sqrt y < x",
        # implicit_vars=[A, B],
        node=-sqrt(B) < A,
        hyps=[A ** 2 < B],
    ),
    lean_rule(
        label="real.sin_arccos",
        statement="∀ {x : ℝ}, -1 ≤ x → x ≤ 1 → real.sin (real.arccos x) = real.sqrt (1 - x ^ 2)",
        # implicit_vars=[A],
        left=sin(acos(A)),
        right=sqrt(1 - A ** 2),
        hyps=[-1 <= A, A <= 1],
    ),
    lean_rule(
        label="real.sin_pi", statement="real.sin real.pi = 0", left=sin(PI), right=ZERO,
    ),
    lean_rule(
        label="real.tanh_zero",
        statement="real.tanh 0 = 0",
        left=tanh(ZERO),
        right=ZERO,
    ),
    lean_rule(
        label="real.pi_div_two_le_two", statement="real.pi / 2 ≤ 2", node=PI / 2 <= 2,
    ),
    lean_rule(
        label="real.cos_two_mul'",
        statement="∀ (x : ℝ), real.cos (2 * x) = real.cos x ^ 2 - real.sin x ^ 2",
        left=cos(2 * A),
        right=cos(A) ** 2 - sin(A) ** 2,
    ),
]

LEAN_RING_RULES: List[LeanRule] = [
    lean_rule(
        label="left_distrib",
        statement="∀ {R : Type x} [_inst_1 : distrib R] (a b c : R), a * (b + c) = a * b + a * c",
        left=A * (B + C),
        right=A * B + A * C,
    ),
    lean_rule(
        label="mul_add",
        statement="∀ {R : Type x} [_inst_1 : distrib R] (a b c : R), a * (b + c) = a * b + a * c",
        left=A * (B + C),
        right=A * B + A * C,
    ),
    lean_rule(
        label="right_distrib",
        statement="∀ {R : Type x} [_inst_1 : distrib R] (a b c : R), (a + b) * c = a * c + b * c",
        left=(A + B) * C,
        right=A * C + B * C,
    ),
    lean_rule(
        label="add_mul",
        statement="∀ {R : Type x} [_inst_1 : distrib R] (a b c : R), (a + b) * c = a * c + b * c",
        left=(A + B) * C,
        right=A * C + B * C,
    ),
    lean_rule(
        label="one_add_one_eq_two",
        statement="∀ {α : Type u} [_inst_1 : semiring α], 1 + 1 = 2",
        left=ONE + ONE,
        right=INode(2),
    ),
    lean_rule(
        label="two_mul",
        statement="∀ {α : Type u} [_inst_1 : semiring α] (n : α), 2 * n = n + n",
        left=INode(2) * A,
        right=A + A,
    ),
    lean_rule(
        label="distrib_three_right",
        statement="∀ {α : Type u} [_inst_1 : semiring α] (a b c d : α), (a + b + c) * d = a * d + b * d + c * d",
        left=(A + B + C) * D,
        right=A * D + B * D + C * D,
    ),
    lean_rule(
        label="mul_two",
        statement="∀ {α : Type u} [_inst_1 : semiring α] (n : α), n * 2 = n + n",
        left=A * INode(2),
        right=A + A,
    ),
    lean_rule(
        label="add_mul_self_eq",
        statement="∀ {α : Type u} [_inst_1 : comm_semiring α] (a b : α), (a + b) * (a + b) = a * a + 2 * a * b + b * b",
        left=(A + B) * (A + B),
        right=A * A + (INode(2) * A) * B + B * B,
    ),
    lean_rule(
        label="neg_mul_eq_neg_mul",
        statement="∀ {α : Type u} [_inst_1 : ring α] (a b : α), -(a * b) = -a * b",
        left=-(A * B),
        right=(-A) * B,
    ),
    lean_rule(
        label="neg_mul_eq_mul_neg",
        statement="∀ {α : Type u} [_inst_1 : ring α] (a b : α), -(a * b) = a * -b",
        left=-(A * B),
        right=A * (-B),
    ),
    lean_rule(
        label="neg_mul_eq_neg_mul_symm",
        statement="∀ {α : Type u} [_inst_1 : ring α] (a b : α), -a * b = -(a * b)",
        left=(-A) * B,
        right=-(A * B),
    ),
    lean_rule(
        label="mul_neg_eq_neg_mul_symm",
        statement="∀ {α : Type u} [_inst_1 : ring α] (a b : α), a * -b = -(a * b)",
        left=A * (-B),
        right=-(A * B),
    ),
    lean_rule(
        label="neg_mul_neg",
        statement="∀ {α : Type u} [_inst_1 : ring α] (a b : α), -a * -b = a * b",
        left=(-A) * -B,
        right=A * B,
    ),
    lean_rule(
        label="neg_mul_comm",
        statement="∀ {α : Type u} [_inst_1 : ring α] (a b : α), -a * b = a * -b",
        left=(-A) * B,
        right=A * (-B),
    ),
    lean_rule(
        label="neg_eq_neg_one_mul",
        statement="∀ {α : Type u} [_inst_1 : ring α] (a : α), -a = (-1) * a",
        left=-A,
        right=(-1) * A,
    ),
    lean_rule(
        label="mul_sub_left_distrib",
        statement="∀ {α : Type u} [_inst_1 : ring α] (a b c : α), a * (b - c) = a * b - a * c",
        left=A * (B - C),
        right=A * B - A * C,
    ),
    lean_rule(
        label="mul_sub",
        statement="∀ {α : Type u} [_inst_1 : ring α] (a b c : α), a * (b - c) = a * b - a * c",
        left=A * (B - C),
        right=A * B - A * C,
    ),
    lean_rule(
        label="mul_sub_right_distrib",
        statement="∀ {α : Type u} [_inst_1 : ring α] (a b c : α), (a - b) * c = a * c - b * c",
        left=(A - B) * C,
        right=A * C - B * C,
    ),
    lean_rule(
        label="sub_mul",
        statement="∀ {α : Type u} [_inst_1 : ring α] (a b c : α), (a - b) * c = a * c - b * c",
        left=(A - B) * C,
        right=A * C - B * C,
    ),
    lean_rule(
        label="mul_neg_one",
        statement="∀ {α : Type u} [_inst_1 : ring α] (a : α), a * -1 = -a",
        left=A * (-1),
        right=-A,
    ),
    lean_rule(
        label="neg_one_mul",
        statement="∀ {α : Type u} [_inst_1 : ring α] (a : α), (-1) * a = -a",
        left=(-1) * A,
        right=-A,
    ),
    # TODO
    # lean_rule(
    #  label="mul_add_eq_mul_add_iff_sub_mul_add_eq",
    #  statement="∀ (: ℝ), a * e + c = b * e + d ↔ (a - b) * e + c = d",
    #  left=a * e + c,
    #  right=b * e + d ↔ (a - b) * e + c = d
    # ),
    # TODO
    # lean_rule(
    #  label="sub_mul_add_eq_of_mul_add_eq_mul_add",
    #  statement="∀ (: ℝ), a * e + c = b * e + d → (a - b) * e + c = d",
    #  left=a * e + c,
    #  right=b * e + d → (a - b) * e + c = d,
    # ),
    # TODO add rules units.
    # lean_rule(
    #     label="units.neg_inv",
    #     statement="∀ (u : ℝ), (-u)⁻¹ = -u⁻¹",
    #     left=(-A).inv(),
    #     right=-A.inv(),
    # ),
    # lean_rule(
    #     label="units.neg_neg", statement="∀ (u : ℝ), --u = u", left=-(-A), right=A,
    # ),
    # lean_rule(
    #     label="units.neg_mul",
    #     statement="∀ (u₁ u₂ : ℝ), (-u₁) * u₂ = -u₁ * u₂",
    #     left=(-A) * B,
    #     right=-A * B,
    # ),
    # lean_rule(
    #     label="units.mul_neg",
    #     statement="∀ (u₁ u₂ : ℝ), u₁ * -u₂ = -u₁ * u₂",
    #     left=A * -B,
    #     right=-A * B,
    # ),
    # lean_rule(
    #     label="units.neg_mul_neg",
    #     statement="∀ (u₁ u₂ : ℝ), (-u₁) * -u₂ = u₁ * u₂",
    #     left=(-A) * -B,
    #     right=A * B,
    # ),
    # lean_rule(
    #     label="units.neg_eq_neg_one_mul",
    #     statement="∀ (u : ℝ), -u = (-1) * u",
    #     left=-A,
    #     right=(-1) * A,
    # ),
    lean_rule(
        label="mul_self_sub_mul_self",
        statement="∀ {α : Type u} [_inst_1 : comm_ring α] (a b : α), a * a - b * b = (a + b) * (a - b)",
        left=A * A - B * B,
        right=(A + B) * (A - B),
    ),
    lean_rule(
        label="mul_self_sub_one",
        statement="∀ {α : Type u} [_inst_1 : comm_ring α] (a : α), a * a - 1 = (a + 1) * (a - 1)",
        left=A * A - ONE,
        right=(A + ONE) * (A - ONE),
    ),
    lean_rule(
        label="succ_ne_self",
        statement="∀ {α : Type u} [_inst_1 : ring α] [_inst_2 : nontrivial α] (a : α), a + 1 ≠ a",
        node=A + 1 != A,
    ),
    lean_rule(
        label="pred_ne_self",
        statement="∀ {α : Type u} [_inst_1 : ring α] [_inst_2 : nontrivial α] (a : α), a - 1 ≠ a",
        node=A - 1 != A,
    ),
    lean_rule(
        label="mul_lt_mul_of_pos_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c : α}, a < b → 0 < c → c * a < c * b",
        # implicit_vars=[A, B, C],
        node=C * A < C * B,
        hyps=[A < B, ZERO < C],
    ),
    lean_rule(
        label="mul_lt_mul_of_pos_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c : α}, a < b → 0 < c → a * c < b * c",
        # implicit_vars=[A, B, C],
        node=A * C < B * C,
        hyps=[A < B, ZERO < C],
    ),
    lean_rule(
        label="mul_le_mul_of_nonneg_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c : α}, a ≤ b → 0 ≤ c → c * a ≤ c * b",
        # implicit_vars=[A, B, C],
        node=C * A <= C * B,
        hyps=[A <= B, ZERO <= C],
    ),
    lean_rule(
        label="mul_le_mul_of_nonneg_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c : α}, a ≤ b → 0 ≤ c → a * c ≤ b * c",
        # implicit_vars=[A, B, C],
        node=A * C <= B * C,
        hyps=[A <= B, ZERO <= C],
    ),
    lean_rule(
        label="mul_le_mul",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c d : α}, a ≤ c → b ≤ d → 0 ≤ b → 0 ≤ c → a * b ≤ c * d",
        # implicit_vars=[A, B, C, D],
        node=A * B <= C * D,
        hyps=[A <= C, B <= D, ZERO <= B, ZERO <= C],
    ),
    lean_rule(
        label="mul_nonneg",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 0 ≤ a → 0 ≤ b → 0 ≤ a * b",
        # implicit_vars=[A, B],
        node=ZERO <= A * B,
        hyps=[ZERO <= A, ZERO <= B],
    ),
    lean_rule(
        label="mul_nonpos_of_nonneg_of_nonpos",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 0 ≤ a → b ≤ 0 → a * b ≤ 0",
        # implicit_vars=[A, B],
        node=A * B <= ZERO,
        hyps=[ZERO <= A, B <= ZERO],
    ),
    lean_rule(
        label="mul_nonpos_of_nonpos_of_nonneg",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, a ≤ 0 → 0 ≤ b → a * b ≤ 0",
        # implicit_vars=[A, B],
        node=A * B <= ZERO,
        hyps=[A <= ZERO, ZERO <= B],
    ),
    lean_rule(
        label="mul_lt_mul",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c d : α}, a < c → b ≤ d → 0 < b → 0 ≤ c → a * b < c * d",
        # implicit_vars=[A, B, C, D],
        node=A * B < C * D,
        hyps=[A < C, B <= D, ZERO < B, ZERO <= C],
    ),
    lean_rule(
        label="mul_lt_mul'",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c d : α}, a ≤ c → b < d → 0 ≤ b → 0 < c → a * b < c * d",
        # implicit_vars=[A, B, C, D],
        node=A * B < C * D,
        hyps=[A <= C, B < D, ZERO <= B, ZERO < C],
    ),
    lean_rule(
        label="mul_pos",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 0 < a → 0 < b → 0 < a * b",
        # implicit_vars=[A, B],
        node=ZERO < A * B,
        hyps=[ZERO < A, ZERO < B],
    ),
    lean_rule(
        label="mul_neg_of_pos_of_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 0 < a → b < 0 → a * b < 0",
        # implicit_vars=[A, B],
        node=A * B < ZERO,
        hyps=[ZERO < A, B < ZERO],
    ),
    lean_rule(
        label="mul_neg_of_neg_of_pos",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, a < 0 → 0 < b → a * b < 0",
        # implicit_vars=[A, B],
        node=A * B < ZERO,
        hyps=[A < ZERO, ZERO < B],
    ),
    lean_rule(
        label="mul_self_le_mul_self",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 0 ≤ a → a ≤ b → a * a ≤ b * b",
        # implicit_vars=[A, B],
        node=A * A <= B * B,
        hyps=[ZERO <= A, A <= B],
    ),
    lean_rule(
        label="mul_self_lt_mul_self",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 0 ≤ a → a < b → a * a < b * b",
        # implicit_vars=[A, B],
        node=A * A < B * B,
        hyps=[ZERO <= A, A < B],
    ),
    lean_rule(
        label="zero_lt_one",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] [_inst_2 : nontrivial α], 0 < 1",
        node=ZERO < ONE,
    ),
    lean_rule(
        label="zero_le_one",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α], 0 ≤ 1",
        node=ZERO <= ONE,
    ),
    lean_rule(
        label="zero_le_two",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α], 0 ≤ 2",
        node=ZERO <= INode(2),
    ),
    lean_rule(
        label="zero_lt_two",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] [_inst_2 : nontrivial α], 0 < 2",
        node=ZERO < INode(2),
    ),
    lean_rule(
        label="two_ne_zero",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] [_inst_2 : nontrivial α], 2 ≠ 0",
        node=INode(2) != ZERO,
    ),
    lean_rule(
        label="one_lt_two",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] [_inst_2 : nontrivial α], 1 < 2",
        node=ONE < INode(2),
    ),
    lean_rule(
        label="one_le_two",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α], 1 ≤ 2",
        node=ONE <= INode(2),
    ),
    lean_rule(
        label="zero_lt_three",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] [_inst_2 : nontrivial α], 0 < 3",
        node=ZERO < 3,
    ),
    lean_rule(
        label="zero_lt_four",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] [_inst_2 : nontrivial α], 0 < 4",
        node=ZERO < 4,
    ),
    lean_rule(
        label="lt_of_mul_lt_mul_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b c : α}, c * a < c * b → 0 ≤ c → a < b",
        # implicit_vars=[A, B, C],
        node=A < B,
        hyps=[C * A < C * B, ZERO <= C],
    ),
    lean_rule(
        label="lt_of_mul_lt_mul_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b c : α}, a * c < b * c → 0 ≤ c → a < b",
        # implicit_vars=[A, B, C],
        node=A < B,
        hyps=[A * C < B * C, ZERO <= C],
    ),
    lean_rule(
        label="le_of_mul_le_mul_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b c : α}, c * a ≤ c * b → 0 < c → a ≤ b",
        # implicit_vars=[A, B, C],
        node=A <= B,
        hyps=[C * A <= C * B, ZERO < C],
    ),
    lean_rule(
        label="le_of_mul_le_mul_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b c : α}, a * c ≤ b * c → 0 < c → a ≤ b",
        # implicit_vars=[A, B, C],
        node=A <= B,
        hyps=[A * C <= B * C, ZERO < C],
    ),
    lean_rule(
        label="pos_of_mul_pos_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 < a * b → 0 ≤ a → 0 < b",
        # implicit_vars=[A, B],
        node=ZERO < B,
        hyps=[ZERO < A * B, ZERO <= A],
    ),
    lean_rule(
        label="pos_of_mul_pos_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 < a * b → 0 ≤ b → 0 < a",
        # implicit_vars=[A, B],
        node=ZERO < A,
        hyps=[ZERO < A * B, ZERO <= B],
    ),
    lean_rule(
        label="nonneg_of_mul_nonneg_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 ≤ a * b → 0 < a → 0 ≤ b",
        # implicit_vars=[A, B],
        node=ZERO <= B,
        hyps=[ZERO <= A * B, ZERO < A],
    ),
    lean_rule(
        label="nonneg_of_mul_nonneg_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 ≤ a * b → 0 < b → 0 ≤ a",
        # implicit_vars=[A, B],
        node=ZERO <= A,
        hyps=[ZERO <= A * B, ZERO < B],
    ),
    lean_rule(
        label="neg_of_mul_neg_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, a * b < 0 → 0 ≤ a → b < 0",
        # implicit_vars=[A, B],
        node=B < ZERO,
        hyps=[A * B < ZERO, ZERO <= A],
    ),
    lean_rule(
        label="neg_of_mul_neg_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, a * b < 0 → 0 ≤ b → a < 0",
        # implicit_vars=[A, B],
        node=A < ZERO,
        hyps=[A * B < ZERO, ZERO <= B],
    ),
    lean_rule(
        label="nonpos_of_mul_nonpos_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, a * b ≤ 0 → 0 < a → b ≤ 0",
        # implicit_vars=[A, B],
        node=B <= ZERO,
        hyps=[A * B <= ZERO, ZERO < A],
    ),
    lean_rule(
        label="nonpos_of_mul_nonpos_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, a * b ≤ 0 → 0 < b → a ≤ 0",
        # implicit_vars=[A, B],
        node=A <= ZERO,
        hyps=[A * B <= ZERO, ZERO < B],
    ),
    lean_rule(
        label="mul_le_mul_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b c : α}, 0 < c → (c * a ≤ c * b ↔ a ≤ b)",
        # implicit_vars=[A, B, C],
        left=C * A <= C * B,
        right=A <= B,
        hyps=[ZERO < C],
    ),
    lean_rule(
        label="mul_le_mul_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b c : α}, 0 < c → (a * c ≤ b * c ↔ a ≤ b)",
        # implicit_vars=[A, B, C],
        left=A * C <= B * C,
        right=A <= B,
        hyps=[ZERO < C],
    ),
    lean_rule(
        label="mul_lt_mul_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b c : α}, 0 < c → (c * a < c * b ↔ a < b)",
        # implicit_vars=[A, B, C],
        left=C * A < C * B,
        right=A < B,
        hyps=[ZERO < C],
    ),
    lean_rule(
        label="mul_lt_mul_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b c : α}, 0 < c → (a * c < b * c ↔ a < b)",
        # implicit_vars=[A, B, C],
        left=A * C < B * C,
        right=A < B,
        hyps=[ZERO < C],
    ),
    lean_rule(
        label="zero_le_mul_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {b c : α}, 0 < c → (0 ≤ c * b ↔ 0 ≤ b)",
        # implicit_vars=[A, B],
        left=ZERO <= B * A,
        right=ZERO <= A,
        hyps=[ZERO < B],
    ),
    lean_rule(
        label="zero_le_mul_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {b c : α}, 0 < c → (0 ≤ b * c ↔ 0 ≤ b)",
        # implicit_vars=[A, B],
        left=ZERO <= A * B,
        right=ZERO <= A,
        hyps=[ZERO < B],
    ),
    lean_rule(
        label="zero_lt_mul_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {b c : α}, 0 < c → (0 < c * b ↔ 0 < b)",
        # implicit_vars=[A, B],
        left=ZERO < B * A,
        right=ZERO < A,
        hyps=[ZERO < B],
    ),
    lean_rule(
        label="zero_lt_mul_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {b c : α}, 0 < c → (0 < b * c ↔ 0 < b)",
        # implicit_vars=[A, B],
        left=ZERO < A * B,
        right=ZERO < A,
        hyps=[ZERO < B],
    ),
    lean_rule(
        label="mul_lt_mul''",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c d : α}, a < c → b < d → 0 ≤ a → 0 ≤ b → a * b < c * d",
        # implicit_vars=[A, B, C, D],
        node=A * B < C * D,
        hyps=[A < C, B < D, ZERO <= A, ZERO <= B],
    ),
    lean_rule(
        label="le_mul_iff_one_le_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 < b → (b ≤ a * b ↔ 1 ≤ a)",
        # implicit_vars=[A, B],
        left=B <= A * B,
        right=ONE <= A,
        hyps=[ZERO < B],
    ),
    lean_rule(
        label="lt_mul_iff_one_lt_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 < b → (b < a * b ↔ 1 < a)",
        # implicit_vars=[A, B],
        left=B < A * B,
        right=ONE < A,
        hyps=[ZERO < B],
    ),
    lean_rule(
        label="le_mul_iff_one_le_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 < b → (b ≤ b * a ↔ 1 ≤ a)",
        # implicit_vars=[A, B],
        left=B <= B * A,
        right=ONE <= A,
        hyps=[ZERO < B],
    ),
    lean_rule(
        label="lt_mul_iff_one_lt_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 < b → (b < b * a ↔ 1 < a)",
        # implicit_vars=[A, B],
        left=B < B * A,
        right=ONE < A,
        hyps=[ZERO < B],
    ),
    lean_rule(
        label="lt_mul_of_one_lt_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 0 < b → 1 < a → b < b * a",
        # implicit_vars=[A, B],
        node=B < B * A,
        hyps=[ZERO < B, ONE < A],
    ),
    lean_rule(
        label="le_mul_of_one_le_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 0 ≤ b → 1 ≤ a → b ≤ b * a",
        # implicit_vars=[A, B],
        node=B <= B * A,
        hyps=[ZERO <= B, ONE <= A],
    ),
    lean_rule(
        label="le_mul_of_one_le_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 0 ≤ b → 1 ≤ a → b ≤ a * b",
        # implicit_vars=[A, B],
        node=B <= A * B,
        hyps=[ZERO <= B, ONE <= A],
    ),
    lean_rule(
        label="mul_nonneg_iff_right_nonneg_of_pos",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 < a → (0 ≤ b * a ↔ 0 ≤ b)",
        # implicit_vars=[A, B],
        left=ZERO <= B * A,
        right=ZERO <= B,
        hyps=[ZERO < A],
    ),
    lean_rule(
        label="lt_add_one",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] [_inst_2 : nontrivial α] (a : α), a < a + 1",
        node=A < A + ONE,
    ),
    lean_rule(
        label="lt_one_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] [_inst_2 : nontrivial α] (a : α), a < 1 + a",
        node=A < ONE + A,
    ),
    lean_rule(
        label="one_lt_mul",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 1 ≤ a → 1 < b → 1 < a * b",
        # implicit_vars=[A, B],
        node=ONE < A * B,
        hyps=[ONE <= A, ONE < B],
    ),
    lean_rule(
        label="mul_le_one",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, a ≤ 1 → 0 ≤ b → b ≤ 1 → a * b ≤ 1",
        # implicit_vars=[A, B],
        node=A * B <= ONE,
        hyps=[A <= ONE, ZERO <= B, B <= ONE],
    ),
    lean_rule(
        label="one_lt_mul_of_le_of_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 1 ≤ a → 1 < b → 1 < a * b",
        # implicit_vars=[A, B],
        node=ONE < A * B,
        hyps=[ONE <= A, ONE < B],
    ),
    lean_rule(
        label="one_lt_mul_of_lt_of_le",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 1 < a → 1 ≤ b → 1 < a * b",
        # implicit_vars=[A, B],
        node=ONE < A * B,
        hyps=[ONE < A, ONE <= B],
    ),
    lean_rule(
        label="mul_le_of_le_one_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 0 ≤ a → b ≤ 1 → a * b ≤ a",
        # implicit_vars=[A, B],
        node=A * B <= A,
        hyps=[ZERO <= A, B <= ONE],
    ),
    lean_rule(
        label="mul_le_of_le_one_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 0 ≤ b → a ≤ 1 → a * b ≤ b",
        # implicit_vars=[A, B],
        node=A * B <= B,
        hyps=[ZERO <= B, A <= ONE],
    ),
    lean_rule(
        label="mul_lt_one_of_nonneg_of_lt_one_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 0 ≤ a → a < 1 → b ≤ 1 → a * b < 1",
        # implicit_vars=[A, B],
        node=A * B < ONE,
        hyps=[ZERO <= A, A < ONE, B <= ONE],
    ),
    lean_rule(
        label="mul_lt_one_of_nonneg_of_lt_one_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, a ≤ 1 → 0 ≤ b → b < 1 → a * b < 1",
        # implicit_vars=[A, B],
        node=A * B < ONE,
        hyps=[A <= ONE, ZERO <= B, B < ONE],
    ),
    lean_rule(
        label="mul_le_iff_le_one_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 < b → (a * b ≤ b ↔ a ≤ 1)",
        # implicit_vars=[A, B],
        left=A * B <= B,
        right=A <= ONE,
        hyps=[ZERO < B],
    ),
    lean_rule(
        label="mul_lt_iff_lt_one_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 < b → (a * b < b ↔ a < 1)",
        # implicit_vars=[A, B],
        left=A * B < B,
        right=A < ONE,
        hyps=[ZERO < B],
    ),
    lean_rule(
        label="mul_le_iff_le_one_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 < b → (b * a ≤ b ↔ a ≤ 1)",
        # implicit_vars=[A, B],
        left=B * A <= B,
        right=A <= ONE,
        hyps=[ZERO < B],
    ),
    lean_rule(
        label="mul_lt_iff_lt_one_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 < b → (b * a < b ↔ a < 1)",
        # implicit_vars=[A, B],
        left=B * A < B,
        right=A < ONE,
        hyps=[ZERO < B],
    ),
    lean_rule(
        label="nonpos_of_mul_nonneg_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 ≤ a * b → b < 0 → a ≤ 0",
        # implicit_vars=[A, B],
        node=A <= ZERO,
        hyps=[ZERO <= A * B, B < ZERO],
    ),
    lean_rule(
        label="nonpos_of_mul_nonneg_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 ≤ a * b → a < 0 → b ≤ 0",
        # implicit_vars=[A, B],
        node=B <= ZERO,
        hyps=[ZERO <= A * B, A < ZERO],
    ),
    lean_rule(
        label="neg_of_mul_pos_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 < a * b → b ≤ 0 → a < 0",
        # implicit_vars=[A, B],
        node=A < ZERO,
        hyps=[ZERO < A * B, B <= ZERO],
    ),
    lean_rule(
        label="neg_of_mul_pos_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 0 < a * b → a ≤ 0 → b < 0",
        # implicit_vars=[A, B],
        node=B < ZERO,
        hyps=[ZERO < A * B, A <= ZERO],
    ),
    # lean_rule(
    #     label="decidable.mul_le_mul_left",
    #     statement="∀ {a b c : ℝ}, 0 < c → c * a ≤ c * b ↔ a ≤ b",
    #     implicit_vars=[A, B, C],
    #     left=C * A <= C * B,
    #     right=A <= B,
    #     hyps=[ZERO < C],
    # ),
    # lean_rule(
    #     label="decidable.mul_le_mul_right",
    #     statement="∀ {a b c : ℝ}, 0 < c → a * c ≤ b * c ↔ a ≤ b",
    #     implicit_vars=[A, B, C],
    #     left=A * C <= B * C,
    #     right=A <= B,
    #     hyps=[ZERO < C],
    # ),
    lean_rule(
        label="ordered_ring.mul_nonneg",
        statement="∀ {α : Type u} [_inst_1 : ordered_ring α] {a b : α}, 0 ≤ a → 0 ≤ b → 0 ≤ a * b",
        # implicit_vars=[A, B],
        node=ZERO <= A * B,
        hyps=[ZERO <= A, ZERO <= B],
    ),
    lean_rule(
        label="ordered_ring.mul_le_mul_of_nonneg_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_ring α] {a b c : α}, a ≤ b → 0 ≤ c → c * a ≤ c * b",
        # implicit_vars=[A, B, C],
        node=C * A <= C * B,
        hyps=[A <= B, ZERO <= C],
    ),
    lean_rule(
        label="ordered_ring.mul_le_mul_of_nonneg_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_ring α] {a b c : α}, a ≤ b → 0 ≤ c → a * c ≤ b * c",
        # implicit_vars=[A, B, C],
        node=A * C <= B * C,
        hyps=[A <= B, ZERO <= C],
    ),
    lean_rule(
        label="ordered_ring.mul_lt_mul_of_pos_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_ring α] {a b c : α}, a < b → 0 < c → c * a < c * b",
        # implicit_vars=[A, B, C],
        node=C * A < C * B,
        hyps=[A < B, ZERO < C],
    ),
    lean_rule(
        label="ordered_ring.mul_lt_mul_of_pos_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_ring α] {a b c : α}, a < b → 0 < c → a * c < b * c",
        # implicit_vars=[A, B, C],
        node=A * C < B * C,
        hyps=[A < B, ZERO < C],
    ),
    lean_rule(
        label="mul_le_mul_of_nonpos_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_ring α] {a b c : α}, b ≤ a → c ≤ 0 → c * a ≤ c * b",
        # implicit_vars=[A, B, C],
        node=C * A <= C * B,
        hyps=[B <= A, C <= ZERO],
    ),
    lean_rule(
        label="mul_le_mul_of_nonpos_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_ring α] {a b c : α}, b ≤ a → c ≤ 0 → a * c ≤ b * c",
        # implicit_vars=[A, B, C],
        node=A * C <= B * C,
        hyps=[B <= A, C <= ZERO],
    ),
    lean_rule(
        label="mul_nonneg_of_nonpos_of_nonpos",
        statement="∀ {α : Type u} [_inst_1 : ordered_ring α] {a b : α}, a ≤ 0 → b ≤ 0 → 0 ≤ a * b",
        # implicit_vars=[A, B],
        node=ZERO <= A * B,
        hyps=[A <= ZERO, B <= ZERO],
    ),
    lean_rule(
        label="mul_lt_mul_of_neg_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_ring α] {a b c : α}, b < a → c < 0 → c * a < c * b",
        # implicit_vars=[A, B, C],
        node=C * A < C * B,
        hyps=[B < A, C < ZERO],
    ),
    lean_rule(
        label="mul_lt_mul_of_neg_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_ring α] {a b c : α}, b < a → c < 0 → a * c < b * c",
        # implicit_vars=[A, B, C],
        node=A * C < B * C,
        hyps=[B < A, C < ZERO],
    ),
    lean_rule(
        label="mul_pos_of_neg_of_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_ring α] {a b : α}, a < 0 → b < 0 → 0 < a * b",
        # implicit_vars=[A, B],
        node=ZERO < A * B,
        hyps=[A < ZERO, B < ZERO],
    ),
    lean_rule(
        label="mul_self_nonneg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] (a : α), 0 ≤ a * a",
        node=ZERO <= A * A,
    ),
    lean_rule(
        label="gt_of_mul_lt_mul_neg_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b c : α}, c * a < c * b → c ≤ 0 → b < a",
        # implicit_vars=[A, B, C],
        node=B < A,
        hyps=[C * A < C * B, C <= ZERO],
    ),
    lean_rule(
        label="neg_one_lt_zero",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α], -1 < 0",
        node=-1 < ZERO,
    ),
    lean_rule(
        label="le_of_mul_le_of_one_le",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b c : α}, a * c ≤ b → 0 ≤ b → 1 ≤ c → a ≤ b",
        # implicit_vars=[A, B, C],
        node=A <= B,
        hyps=[A * C <= B, ZERO <= B, ONE <= C],
    ),
    # lean_rule(  # NOT IN OUR MATHLIB
    #     label="nonneg_le_nonneg_of_squares_le",
    #     statement="∀ {a b : ℝ}, 0 ≤ b → a * a ≤ b * b → a ≤ b",
    #     implicit_vars=[A, B],
    #     node=A <= B,
    #     hyps=[ZERO <= B, A * A <= B * B],
    # ),
    lean_rule(
        label="mul_self_le_mul_self_iff",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b : α}, 0 ≤ a → 0 ≤ b → (a ≤ b ↔ a * a ≤ b * b)",
        # implicit_vars=[A, B],
        left=A <= B,
        right=A * A <= B * B,
        hyps=[ZERO <= A, ZERO <= B],
    ),
    lean_rule(
        label="mul_self_lt_mul_self_iff",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b : α}, 0 ≤ a → 0 ≤ b → (a < b ↔ a * a < b * b)",
        # implicit_vars=[A, B],
        left=A < B,
        right=A * A < B * B,
        hyps=[ZERO <= A, ZERO <= B],
    ),
    lean_rule(
        label="mul_le_mul_left_of_neg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b c : α}, c < 0 → (c * a ≤ c * b ↔ b ≤ a)",
        # implicit_vars=[A, B, C],
        left=C * A <= C * B,
        right=B <= A,
        hyps=[C < ZERO],
    ),
    lean_rule(
        label="mul_le_mul_right_of_neg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b c : α}, c < 0 → (a * c ≤ b * c ↔ b ≤ a)",
        # implicit_vars=[A, B, C],
        left=A * C <= B * C,
        right=B <= A,
        hyps=[C < ZERO],
    ),
    lean_rule(
        label="mul_lt_mul_left_of_neg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b c : α}, c < 0 → (c * a < c * b ↔ b < a)",
        # implicit_vars=[A, B, C],
        left=C * A < C * B,
        right=B < A,
        hyps=[C < ZERO],
    ),
    lean_rule(
        label="mul_lt_mul_right_of_neg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b c : α}, c < 0 → (a * c < b * c ↔ b < a)",
        # implicit_vars=[A, B, C],
        left=A * C < B * C,
        right=B < A,
        hyps=[C < ZERO],
    ),
    lean_rule(
        label="sub_one_lt",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] (a : α), a - 1 < a",
        node=A - ONE < A,
    ),
    lean_rule(
        label="mul_self_pos",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a : α}, a ≠ 0 → 0 < a * a",
        # implicit_vars=[A],
        node=ZERO < A * A,
        hyps=[A != ZERO],
    ),
    lean_rule(
        label="mul_self_le_mul_self_of_le_of_neg_le",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {x y : α}, x ≤ y → -x ≤ y → x * x ≤ y * y",
        # implicit_vars=[A, B],
        node=A * A <= B * B,
        hyps=[A <= B, -A <= B],
    ),
    lean_rule(
        label="nonneg_of_mul_nonpos_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b : α}, a * b ≤ 0 → b < 0 → 0 ≤ a",
        # implicit_vars=[A, B],
        node=ZERO <= A,
        hyps=[A * B <= ZERO, B < ZERO],
    ),
    lean_rule(
        label="nonneg_of_mul_nonpos_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b : α}, a * b ≤ 0 → a < 0 → 0 ≤ b",
        # implicit_vars=[A, B],
        node=ZERO <= B,
        hyps=[A * B <= ZERO, A < ZERO],
    ),
    lean_rule(
        label="pos_of_mul_neg_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b : α}, a * b < 0 → b ≤ 0 → 0 < a",
        # implicit_vars=[A, B],
        node=ZERO < A,
        hyps=[A * B < ZERO, B <= ZERO],
    ),
    lean_rule(
        label="pos_of_mul_neg_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b : α}, a * b < 0 → a ≤ 0 → 0 < b",
        # implicit_vars=[A, B],
        node=ZERO < B,
        hyps=[A * B < ZERO, A <= ZERO],
    ),
    lean_rule(
        label="abs_mul",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] (a b : α), abs (a * b) = abs a * abs b",
        left=abs(A * B),
        right=(abs(A)) * abs(B),
    ),
    lean_rule(
        label="abs_mul_abs_self",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] (a : α), abs a * abs a = a * a",
        left=(abs(A)) * abs(A),
        right=A * A,
    ),
    lean_rule(
        label="abs_mul_self",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] (a : α), abs (a * a) = a * a",
        left=abs(A * A),
        right=A * A,
    ),
    lean_rule(
        label="sub_le_of_abs_sub_le_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b c : α}, abs (a - b) ≤ c → b - c ≤ a",
        # implicit_vars=[A, B, C],
        node=B - C <= A,
        hyps=[abs(A - B) <= C],
    ),
    lean_rule(
        label="sub_le_of_abs_sub_le_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b c : α}, abs (a - b) ≤ c → a - c ≤ b",
        # implicit_vars=[A, B, C],
        node=A - C <= B,
        hyps=[abs(A - B) <= C],
    ),
    lean_rule(
        label="sub_lt_of_abs_sub_lt_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b c : α}, abs (a - b) < c → b - c < a",
        # implicit_vars=[A, B, C],
        node=B - C < A,
        hyps=[abs(A - B) < C],
    ),
    lean_rule(
        label="sub_lt_of_abs_sub_lt_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b c : α}, abs (a - b) < c → a - c < b",
        # implicit_vars=[A, B, C],
        node=A - C < B,
        hyps=[abs(A - B) < C],
    ),
    # lean_rule(  # NOT IN OUR MATHLIB
    #     label="abs_sub_square",
    #     statement="∀ (a b : ℝ), (abs (a - b)) * abs (a - b) = a * a + b * b - ((1 + 1) * a) * b",
    #     left=(abs(A - B)) * abs(A - B),
    #     right=A * A + B * B - ((ONE + ONE) * A) * B,
    # ),
    lean_rule(
        label="eq_zero_of_mul_self_add_mul_self_eq_zero",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b : α}, a * a + b * b = 0 → a = 0",
        # implicit_vars=[A, B],
        left=A,
        right=ZERO,
        hyps=[A * A + B * B == ZERO],
    ),
    lean_rule(
        label="abs_abs_sub_abs_le_abs_sub",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b : α), abs (abs a - abs b) ≤ abs (a - b)",
        node=abs(abs(A) - abs(B)) <= abs(A - B),
    ),
    lean_rule(
        label="abs_two",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α], abs 2 = 2",
        left=abs(INode(2)),
        right=INode(2),
    ),
    # lean_rule(
    #     label="canonically_ordered_semiring.mul_le_mul",
    #     statement="∀ {α : Type u} [_inst_1 : canonically_ordered_comm_semiring α] {a b c d : α}, a ≤ b → c ≤ d → a * c ≤ b * d",
    #     implicit_vars=[A, B, C, D],
    #     node=A * C <= B * D,
    #     hyps=[A <= B, C <= D],
    # ),
    # lean_rule(
    #     label="canonically_ordered_semiring.mul_le_mul_left'",
    #     statement="∀ {α : Type u} [_inst_1 : canonically_ordered_comm_semiring α] {b c : α}, b ≤ c → ∀ (a : α), a * b ≤ a * c",
    #     implicit_vars=[B, C],
    #     node=A * B <= A * C,
    #     hyps=[B <= C],
    #     hyp_first=True,
    # ),
    # lean_rule(
    #     label="canonically_ordered_semiring.mul_le_mul_right'",
    #     statement="∀ {α : Type u} [_inst_1 : canonically_ordered_comm_semiring α] {b c : α}, b ≤ c → ∀ (a : α), b * a ≤ c * a",
    #     implicit_vars=[B, C],
    #     node=B * A <= C * A,
    #     hyps=[B <= C],
    #     hyp_first=True,
    # ),
    # lean_rule(
    #     label="canonically_ordered_semiring.zero_lt_one",
    #     statement="∀ {α : Type u} [_inst_1 : canonically_ordered_comm_semiring α] [_inst_2 : nontrivial α], 0 < 1",
    #     node=ZERO < ONE,
    # ),
    lean_rule(
        label="mul_max_of_nonneg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a : α} (b c : α), 0 ≤ a → a * max b c = max (a * b) (a * c)",
        # implicit_vars=[A],
        left=A * Max(B, C),
        right=Max((A * B), (A * C)),
        hyps=[ZERO <= A],
    ),
    lean_rule(
        label="mul_min_of_nonneg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a : α} (b c : α), 0 ≤ a → a * min b c = min (a * b) (a * c)",
        # implicit_vars=[A],
        left=A * Min(B, C),
        right=Min((A * B), (A * C)),
        hyps=[ZERO <= A],
    ),
    lean_rule(
        label="max_mul_of_nonneg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {c : α} (a b : α), 0 ≤ c → max a b * c = max (a * c) (b * c)",
        # implicit_vars=[A],
        left=(Max(B, C)) * A,
        right=Max((B * A), (C * A)),
        hyps=[ZERO <= A],
    ),
    lean_rule(
        label="min_mul_of_nonneg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {c : α} (a b : α), 0 ≤ c → min a b * c = min (a * c) (b * c)",
        # implicit_vars=[A],
        left=(Min(B, C)) * A,
        right=Min((B * A), (C * A)),
        hyps=[ZERO <= A],
    ),
    lean_rule(
        label="nonneg_le_nonneg_of_sq_le_sq",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b : α}, 0 ≤ b → a * a ≤ b * b → a ≤ b",
        # implicit_vars=[A, B],
        node=A <= B,
        hyps=[ZERO <= B, A * A <= B * B],
    ),
    lean_rule(
        label="mul_self_inj",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b : α}, 0 ≤ a → 0 ≤ b → (a * a = b * b ↔ a = b)",
        # implicit_vars=[A, B],
        left=A * A == B * B,
        right=A == B,
        hyps=[ZERO <= A, ZERO <= B],
    ),
    lean_rule(
        label="abs_eq_iff_mul_self_eq",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b : α}, abs a = abs b ↔ a * a = b * b",
        # implicit_vars=[A, B],
        left=abs(A) == abs(B),
        right=A * A == B * B,
    ),
    lean_rule(
        label="abs_lt_iff_mul_self_lt",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b : α}, abs a < abs b ↔ a * a < b * b",
        # implicit_vars=[A, B],
        left=abs(A) < abs(B),
        right=A * A < B * B,
    ),
    lean_rule(
        label="abs_le_iff_mul_self_le",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b : α}, abs a ≤ abs b ↔ a * a ≤ b * b",
        # implicit_vars=[A, B],
        left=abs(A) <= abs(B),
        right=A * A <= B * B,
    ),
    lean_rule(
        label="abs_le_one_iff_mul_self_le_one",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a : α}, abs a ≤ 1 ↔ a * a ≤ 1",
        # implicit_vars=[A],
        left=abs(A) <= ONE,
        right=A * A <= ONE,
    ),
    lean_rule(
        label="max_mul_mul_le_max_mul_max",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_comm_ring α] {a d : α} (b c : α), 0 ≤ a → 0 ≤ d → max (a * b) (d * c) ≤ max a c * max d b",
        # implicit_vars=[A, B],
        node=Max((A * C), (B * D)) <= (Max(A, D)) * Max(B, C),
        hyps=[ZERO <= A, ZERO <= B],
    ),
    lean_rule(
        label="abs_sub_sq",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_comm_ring α] (a b : α), abs (a - b) * abs (a - b) = a * a + b * b - (1 + 1) * a * b",
        left=(abs(A - B)) * abs(A - B),
        right=A * A + B * B - ((ONE + ONE) * A) * B,
    ),
    lean_rule(
        label="add_one_le_two_mul",
        statement="∀ {α : Type u} [_inst_1 : preorder α] [_inst_2 : semiring α] [_inst_3 : covariant_class α α has_add.add has_le.le] {a : α}, 1 ≤ a → a + 1 ≤ 2 * a",
        # implicit_vars=[A],
        node=A + ONE <= INode(2) * A,
        hyps=[ONE <= A],
    ),
    # lean_rule(
    #     label="decidable.mul_le_mul_of_nonneg_left",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c : α} [_inst_2 : decidable_rel has_le.le], a ≤ b → 0 ≤ c → c * a ≤ c * b",
    #     implicit_vars=[A, B, C],
    #     node=C * A <= C * B,
    #     hyps=[A <= B, ZERO <= C],
    # ),
    # lean_rule(
    #     label="decidable.mul_le_mul_of_nonneg_right",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c : α} [_inst_2 : decidable_rel has_le.le], a ≤ b → 0 ≤ c → a * c ≤ b * c",
    #     implicit_vars=[A, B, C],
    #     node=A * C <= B * C,
    #     hyps=[A <= B, ZERO <= C],
    # ),
    # lean_rule(
    #     label="decidable.mul_le_mul",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c d : α} [_inst_2 : decidable_rel has_le.le], a ≤ c → b ≤ d → 0 ≤ b → 0 ≤ c → a * b ≤ c * d",
    #     implicit_vars=[A, B, C, D],
    #     node=A * B <= C * D,
    #     hyps=[A <= C, B <= D, ZERO <= B, ZERO <= C],
    # ),
    # lean_rule(
    #     label="decidable.mul_nonneg_le_one_le",
    #     statement="∀ {α : Type u_1} [_inst_2 : ordered_semiring α] [_inst_3 : decidable_rel has_le.le] {a b c : α}, 0 ≤ c → a ≤ c → 0 ≤ b → b ≤ 1 → a * b ≤ c",
    #     implicit_vars=[A, B, C],
    #     node=A * B <= C,
    #     hyps=[ZERO <= C, A <= C, ZERO <= B, B <= ONE],
    # ),
    # lean_rule(
    #     label="decidable.mul_nonneg",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 0 ≤ a → 0 ≤ b → 0 ≤ a * b",
    #     implicit_vars=[A, B],
    #     node=ZERO <= A * B,
    #     hyps=[ZERO <= A, ZERO <= B],
    # ),
    # lean_rule(
    #     label="decidable.mul_nonpos_of_nonneg_of_nonpos",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 0 ≤ a → b ≤ 0 → a * b ≤ 0",
    #     implicit_vars=[A, B],
    #     node=A * B <= ZERO,
    #     hyps=[ZERO <= A, B <= ZERO],
    # ),
    # lean_rule(
    #     label="decidable.mul_nonpos_of_nonpos_of_nonneg",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], a ≤ 0 → 0 ≤ b → a * b ≤ 0",
    #     implicit_vars=[A, B],
    #     node=A * B <= ZERO,
    #     hyps=[A <= ZERO, ZERO <= B],
    # ),
    # lean_rule(
    #     label="decidable.mul_lt_mul",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c d : α} [_inst_2 : decidable_rel has_le.le], a < c → b ≤ d → 0 < b → 0 ≤ c → a * b < c * d",
    #     implicit_vars=[A, B, C, D],
    #     node=A * B < C * D,
    #     hyps=[A < C, B <= D, ZERO < B, ZERO <= C],
    # ),
    # lean_rule(
    #     label="decidable.mul_lt_mul'",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c d : α} [_inst_2 : decidable_rel has_le.le], a ≤ c → b < d → 0 ≤ b → 0 < c → a * b < c * d",
    #     implicit_vars=[A, B, C, D],
    #     node=A * B < C * D,
    #     hyps=[A <= C, B < D, ZERO <= B, ZERO < C],
    # ),
    # lean_rule(
    #     label="decidable.mul_self_lt_mul_self",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 0 ≤ a → a < b → a * a < b * b",
    #     implicit_vars=[A, B],
    #     node=A * A < B * B,
    #     hyps=[ZERO <= A, A < B],
    # ),
    # lean_rule(
    #     label="decidable.mul_self_le_mul_self",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 0 ≤ a → a ≤ b → a * a ≤ b * b",
    #     implicit_vars=[A, B],
    #     node=A * A <= B * B,
    #     hyps=[ZERO <= A, A <= B],
    # ),
    # lean_rule(
    #     label="decidable.mul_lt_mul''",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b c d : α} [_inst_2 : decidable_rel has_le.le], a < c → b < d → 0 ≤ a → 0 ≤ b → a * b < c * d",
    #     implicit_vars=[A, B, C, D],
    #     node=A * B < C * D,
    #     hyps=[A < C, B < D, ZERO <= A, ZERO <= B],
    # ),
    # lean_rule(
    #     label="decidable.le_mul_of_one_le_right",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 0 ≤ b → 1 ≤ a → b ≤ b * a",
    #     implicit_vars=[A, B],
    #     node=B <= B * A,
    #     hyps=[ZERO <= B, ONE <= A],
    # ),
    # lean_rule(
    #     label="decidable.le_mul_of_one_le_left",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 0 ≤ b → 1 ≤ a → b ≤ a * b",
    #     implicit_vars=[A, B],
    #     node=B <= A * B,
    #     hyps=[ZERO <= B, ONE <= A],
    # ),
    # lean_rule(
    #     label="decidable.lt_mul_of_one_lt_right",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 0 < b → 1 < a → b < b * a",
    #     implicit_vars=[A, B],
    #     node=B < B * A,
    #     hyps=[ZERO < B, ONE < A],
    # ),
    # lean_rule(
    #     label="decidable.lt_mul_of_one_lt_left",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 0 < b → 1 < a → b < a * b",
    #     implicit_vars=[A, B],
    #     node=B < A * B,
    #     hyps=[ZERO < B, ONE < A],
    # ),
    # lean_rule(
    #     label="decidable.add_le_mul_two_add",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] [_inst_2 : decidable_rel has_le.le] {a b : α}, 2 ≤ a → 0 ≤ b → a + (2 + b) ≤ a * (2 + b)",
    #     implicit_vars=[A, B],
    #     node=A + (INode(2) + B) <= A * (INode(2) + B),
    #     hyps=[INode(2) <= A, ZERO <= B],
    # ),
    # lean_rule(
    #     label="decidable.one_le_mul_of_one_le_of_one_le",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] [_inst_2 : decidable_rel has_le.le] {a b : α}, 1 ≤ a → 1 ≤ b → 1 ≤ a * b",
    #     implicit_vars=[A, B],
    #     node=ONE <= A * B,
    #     hyps=[ONE <= A, ONE <= B],
    # ),
    # lean_rule(
    #     label="decidable.one_lt_mul",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 1 ≤ a → 1 < b → 1 < a * b",
    #     implicit_vars=[A, B],
    #     node=ONE < A * B,
    #     hyps=[ONE <= A, ONE < B],
    # ),
    # lean_rule(
    #     label="decidable.mul_le_one",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], a ≤ 1 → 0 ≤ b → b ≤ 1 → a * b ≤ 1",
    #     implicit_vars=[A, B],
    #     node=A * B <= ONE,
    #     hyps=[A <= ONE, ZERO <= B, B <= ONE],
    # ),
    # lean_rule(
    #     label="decidable.one_lt_mul_of_le_of_lt",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 1 ≤ a → 1 < b → 1 < a * b",
    #     implicit_vars=[A, B],
    #     node=ONE < A * B,
    #     hyps=[ONE <= A, ONE < B],
    # ),
    # lean_rule(
    #     label="decidable.one_lt_mul_of_lt_of_le",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 1 < a → 1 ≤ b → 1 < a * b",
    #     implicit_vars=[A, B],
    #     node=ONE < A * B,
    #     hyps=[ONE < A, ONE <= B],
    # ),
    # lean_rule(
    #     label="decidable.mul_le_of_le_one_right",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 0 ≤ a → b ≤ 1 → a * b ≤ a",
    #     implicit_vars=[A, B],
    #     node=A * B <= A,
    #     hyps=[ZERO <= A, B <= ONE],
    # ),
    # lean_rule(
    #     label="decidable.mul_le_of_le_one_left",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 0 ≤ b → a ≤ 1 → a * b ≤ b",
    #     implicit_vars=[A, B],
    #     node=A * B <= B,
    #     hyps=[ZERO <= B, A <= ONE],
    # ),
    # lean_rule(
    #     label="decidable.mul_lt_one_of_nonneg_of_lt_one_left",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], 0 ≤ a → a < 1 → b ≤ 1 → a * b < 1",
    #     implicit_vars=[A, B],
    #     node=A * B < ONE,
    #     hyps=[ZERO <= A, A < ONE, B <= ONE],
    # ),
    # lean_rule(
    #     label="decidable.mul_lt_one_of_nonneg_of_lt_one_right",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α} [_inst_2 : decidable_rel has_le.le], a ≤ 1 → 0 ≤ b → b < 1 → a * b < 1",
    #     implicit_vars=[A, B],
    #     node=A * B < ONE,
    #     hyps=[A <= ONE, ZERO <= B, B < ONE],
    # ),
    lean_rule(
        label="zero_lt_one'",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α], 0 < 1",
        node=ZERO < ONE,
    ),
    lean_rule(
        label="add_le_mul_of_left_le_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 2 ≤ a → a ≤ b → a + b ≤ a * b",
        # implicit_vars=[A, B],
        node=A + B <= A * B,
        hyps=[INode(2) <= A, A <= B],
    ),
    lean_rule(
        label="add_le_mul_of_right_le_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 2 ≤ b → b ≤ a → a + b ≤ a * b",
        # implicit_vars=[A, B],
        node=A + B <= A * B,
        hyps=[INode(2) <= B, B <= A],
    ),
    lean_rule(
        label="add_le_mul",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 2 ≤ a → 2 ≤ b → a + b ≤ a * b",
        # implicit_vars=[A, B],
        node=A + B <= A * B,
        hyps=[INode(2) <= A, INode(2) <= B],
    ),
    lean_rule(
        label="add_le_mul'",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b : α}, 2 ≤ a → 2 ≤ b → a + b ≤ b * a",
        # implicit_vars=[A, B],
        node=A + B <= B * A,
        hyps=[INode(2) <= A, INode(2) <= B],
    ),
    # lean_rule(
    #     label="decidable.ordered_ring.mul_nonneg",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_ring α] [_inst_2 : decidable_rel has_le.le] {a b : α}, 0 ≤ a → 0 ≤ b → 0 ≤ a * b",
    #     implicit_vars=[A, B],
    #     node=ZERO <= A * B,
    #     hyps=[ZERO <= A, ZERO <= B],
    # ),
    # lean_rule(
    #     label="decidable.ordered_ring.mul_le_mul_of_nonneg_left",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_ring α] {a b c : α} [_inst_2 : decidable_rel has_le.le], a ≤ b → 0 ≤ c → c * a ≤ c * b",
    #     implicit_vars=[A, B, C],
    #     node=C * A <= C * B,
    #     hyps=[A <= B, ZERO <= C],
    # ),
    # lean_rule(
    #     label="decidable.ordered_ring.mul_le_mul_of_nonneg_right",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_ring α] {a b c : α} [_inst_2 : decidable_rel has_le.le], a ≤ b → 0 ≤ c → a * c ≤ b * c",
    #     implicit_vars=[A, B, C],
    #     node=A * C <= B * C,
    #     hyps=[A <= B, ZERO <= C],
    # ),
    # lean_rule(
    #     label="decidable.mul_le_mul_of_nonpos_left",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_ring α] [_inst_2 : decidable_rel has_le.le] {a b c : α}, b ≤ a → c ≤ 0 → c * a ≤ c * b",
    #     implicit_vars=[A, B, C],
    #     node=C * A <= C * B,
    #     hyps=[B <= A, C <= ZERO],
    # ),
    # lean_rule(
    #     label="decidable.mul_le_mul_of_nonpos_right",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_ring α] [_inst_2 : decidable_rel has_le.le] {a b c : α}, b ≤ a → c ≤ 0 → a * c ≤ b * c",
    #     implicit_vars=[A, B, C],
    #     node=A * C <= B * C,
    #     hyps=[B <= A, C <= ZERO],
    # ),
    # lean_rule(
    #     label="decidable.mul_nonneg_of_nonpos_of_nonpos",
    #     statement="∀ {α : Type u} [_inst_1 : ordered_ring α] [_inst_2 : decidable_rel has_le.le] {a b : α}, a ≤ 0 → b ≤ 0 → 0 ≤ a * b",
    #     implicit_vars=[A, B],
    #     node=ZERO <= A * B,
    #     hyps=[A <= ZERO, B <= ZERO],
    # ),
    lean_rule(
        label="abs_one",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α], abs 1 = 1",
        left=abs(ONE),
        right=ONE,
    ),
    lean_rule(
        label="neg_le_self_iff",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a : α}, -a ≤ a ↔ 0 ≤ a",
        # implicit_vars=[A],
        left=-A <= A,
        right=ZERO <= A,
    ),
    lean_rule(
        label="neg_lt_self_iff",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a : α}, -a < a ↔ 0 < a",
        # implicit_vars=[A],
        left=-A < A,
        right=ZERO < A,
    ),
    lean_rule(
        label="le_neg_self_iff",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a : α}, a ≤ -a ↔ a ≤ 0",
        # implicit_vars=[A],
        left=A <= -A,
        right=A <= ZERO,
    ),
    lean_rule(
        label="lt_neg_self_iff",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a : α}, a < -a ↔ a < 0",
        # implicit_vars=[A],
        left=A < -A,
        right=A < ZERO,
    ),
    lean_rule(
        label="abs_eq_self",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a : α}, abs a = a ↔ 0 ≤ a",
        # implicit_vars=[A],
        left=abs(A) == A,
        right=ZERO <= A,
    ),
    lean_rule(
        label="abs_eq_neg_self",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a : α}, abs a = -a ↔ a ≤ 0",
        # implicit_vars=[A],
        left=abs(A) == -A,
        right=A <= ZERO,
    ),
    lean_rule(
        label="mul_nonneg_le_one_le",
        statement="∀ {α : Type u_1} [_inst_2 : ordered_semiring α] {a b c : α}, 0 ≤ c → a ≤ c → 0 ≤ b → b ≤ 1 → a * b ≤ c",
        # implicit_vars=[A, B, C],
        node=A * B <= C,
        hyps=[ZERO <= C, A <= C, ZERO <= B, B <= ONE],
    ),
    lean_rule(
        label="lt_mul_of_one_lt_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 0 < b → 1 < a → b < a * b",
        # implicit_vars=[A, B],
        node=B < A * B,
        hyps=[ZERO < B, ONE < A],
    ),
    lean_rule(
        label="add_le_mul_two_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 2 ≤ a → 0 ≤ b → a + (2 + b) ≤ a * (2 + b)",
        # implicit_vars=[A, B],
        node=A + (INode(2) + B) <= A * (INode(2) + B),
        hyps=[INode(2) <= A, ZERO <= B],
    ),
    lean_rule(
        label="one_le_mul_of_one_le_of_one_le",
        statement="∀ {α : Type u} [_inst_1 : ordered_semiring α] {a b : α}, 1 ≤ a → 1 ≤ b → 1 ≤ a * b",
        # implicit_vars=[A, B],
        node=ONE <= A * B,
        hyps=[ONE <= A, ONE <= B],
    ),
]

LEAN_GROUPS_RULES: List[LeanRule] = [
    # lean_rule(
    #     label="mul_left_comm",
    #     statement="∀ (a b c : ℝ), a * b * c = b * a * c",
    #     left=A * B * C,
    #     right=B * A * C,
    # ),
    lean_rule(
        label="add_left_comm",
        statement="∀ {G : Type u} [_inst_1 : add_comm_semigroup G] (a b c : G), a + (b + c) = b + (a + c)",
        left=A + (B + C),
        right=B + (A + C),
    ),
    # lean_rule(
    #     label="mul_right_comm",
    #     statement="∀ (a b c : ℝ), (a * b) * c = (a * c) * b",
    #     left=(A * B) * C,
    #     right=(A * C) * B,
    # ),
    lean_rule(
        label="add_right_comm",
        statement="∀ {G : Type u} [_inst_1 : add_comm_semigroup G] (a b c : G), a + b + c = a + c + b",
        left=A + B + C,
        right=A + C + B,
    ),
    lean_rule(
        label="add_add_add_comm",
        statement="∀ {G : Type u} [_inst_1 : add_comm_semigroup G] (a b c d : G), a + b + (c + d) = a + c + (b + d)",
        left=A + B + (C + D),
        right=A + C + (B + D),
    ),
    # # lean_rule(
    # #     label="mul_mul_mul_comm",
    # #     statement="∀ (a b c d : ℝ), (a * b) * c * d = (a * c) * b * d",
    # #     left=(A * B) * C * D,
    # #     right=(A * C) * B * D,
    # # ),
    # lean_rule(
    #     label="inv_unique",
    #     statement="∀ {x y z : ℝ}, x * y = 1 → x * z = 1 → y = z",
    #     implicit_vars=[A, B, C],
    #     left=B,
    #     right=C,
    #     hyps=[A * B == ONE, A * C == ONE],
    # ),
    lean_rule(
        label="neg_unique",
        statement="∀ {M : Type u} [_inst_1 : add_comm_monoid M] {x y z : M}, x + y = 0 → x + z = 0 → y = z",
        # implicit_vars=[A, B, C],
        left=B,
        right=C,
        hyps=[A + B == ZERO, A + C == ZERO],
    ),
    # lean_rule(
    #     label="eq_one_of_mul_self_left_cancel",
    #     statement="∀ {a : ℝ}, a * a = a → a = 1",
    #     implicit_vars=[A],
    #     left=A,
    #     right=ONE,
    #     hyps=[A * A == A],
    # ),
    # lean_rule(
    #     label="eq_zero_of_add_self_left_cancel",
    #     statement="∀ {a : ℝ}, a + a = a → a = 0",
    #     implicit_vars=[A],
    #     left=A,
    #     right=ZERO,
    #     hyps=[A + A == A],
    # ),
    # lean_rule(
    #     label="eq_zero_of_left_cancel_add_self",
    #     statement="∀ {a : ℝ}, a = a + a → a = 0",
    #     implicit_vars=[A],
    #     left=A,
    #     right=ZERO,
    #     hyps=[A == A + A],
    # ),
    # lean_rule(
    #     label="eq_one_of_left_cancel_mul_self",
    #     statement="∀ {a : ℝ}, a = a * a → a = 1",
    #     implicit_vars=[A],
    #     left=A,
    #     right=ONE,
    #     hyps=[A == A * A],
    # ),
    # lean_rule(
    #     label="eq_zero_of_add_self_right_cancel",
    #     statement="∀ {a : ℝ}, a + a = a → a = 0",
    #     implicit_vars=[A],
    #     left=A,
    #     right=ZERO,
    #     hyps=[A + A == A],
    # ),
    # # lean_rule(
    # #     label="eq_one_of_mul_self_right_cancel",
    # #     statement="∀ {a : ℝ}, a * a = a → a = 1",
    # #     implicit_vars=[A],
    # #     left=A,
    # #     right=ONE,
    # #     hyps=[A * A == A],
    # # ),
    # lean_rule(
    #     label="eq_one_of_right_cancel_mul_self",
    #     statement="∀ {a : ℝ}, a = a * a → a = 1",
    #     implicit_vars=[A],
    #     left=A,
    #     right=ONE,
    #     hyps=[A == A * A],
    # ),
    # lean_rule(
    #     label="eq_zero_of_right_cancel_add_self",
    #     statement="∀ {a : ℝ}, a = a + a → a = 0",
    #     implicit_vars=[A],
    #     left=A,
    #     right=ZERO,
    #     hyps=[A == A + A],
    # ),
    lean_rule(
        label="neg_add_cancel_right",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a b : G), a + -b + b = a",
        left=A + (-B) + B,
        right=A,
    ),
    # lean_rule(
    #     label="inv_mul_cancel_right",
    #     statement="∀ (a b : ℝ), (a * b⁻¹) * b = a",
    #     left=(A * B.inv()) * B,
    #     right=A,
    # ),
    # lean_rule(label="one_inv", statement="1⁻¹ = 1", left=ONE.inv(), right=ONE),
    lean_rule(
        label="neg_zero",
        statement="∀ {G : Type u} [_inst_1 : add_group G], -0 = 0",
        left=-ZERO,
        right=ZERO,
    ),
    # lean_rule(
    #     label="inv_inj",
    #     statement="∀ {a b : ℝ}, a⁻¹ = b⁻¹ ↔ a = b",
    #     implicit_vars=[A, B],
    #     left=A.inv() == B.inv(),
    #     right=A == B,
    # ),
    lean_rule(
        label="neg_inj",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, -a = -b ↔ a = b",
        # implicit_vars=[A, B],
        left=-A == -B,
        right=A == B,
    ),
    # lean_rule(
    #     label="mul_inv_cancel_left",
    #     statement="∀ (a b : ℝ), a * a⁻¹ * b = b",
    #     left=A * A.inv() * B,
    #     right=B,
    # ),
    lean_rule(
        label="add_neg_cancel_left",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a b : G), a + (-a + b) = b",
        left=A + (-A + B),
        right=B,
    ),
    # lean_rule(
    #     label="mul_inv_rev",
    #     statement="∀ (a b : ℝ), (a * b)⁻¹ = b⁻¹ * a⁻¹",
    #     left=(A * B).inv(),
    #     right=B.inv() * A.inv(),
    # ),
    lean_rule(
        label="neg_add_rev",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a b : G), -(a + b) = -b + -a",
        left=-(A + B),
        right=-B + -A,
    ),
    # lean_rule(
    #     label="eq_inv_of_eq_inv",
    #     statement="∀ {a b : ℝ}, a = b⁻¹ → b = a⁻¹",
    #     implicit_vars=[A, B],
    #     left=B,
    #     right=A.inv(),
    #     hyps=[A == B.inv()],
    # ),
    lean_rule(
        label="eq_neg_of_eq_neg",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, a = -b → b = -a",
        # implicit_vars=[A, B],
        left=B,
        right=-A,
        hyps=[A == -B],
    ),
    # lean_rule(
    #     label="eq_inv_of_mul_eq_one",
    #     statement="∀ {a b : ℝ}, a * b = 1 → a = b⁻¹",
    #     implicit_vars=[A, B],
    #     left=A,
    #     right=B.inv(),
    #     hyps=[A * B == ONE],
    # ),
    lean_rule(
        label="eq_neg_of_add_eq_zero",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, a + b = 0 → a = -b",
        # implicit_vars=[A, B],
        left=A,
        right=-B,
        hyps=[A + B == ZERO],
    ),
    lean_rule(
        label="eq_add_neg_of_add_eq",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a + c = b → a = b + -c",
        # implicit_vars=[A, B, C],
        left=A,
        right=B + -C,
        hyps=[A + C == B],
    ),
    # lean_rule(
    #     label="eq_mul_inv_of_mul_eq",
    #     statement="∀ {a b c : ℝ}, a * c = b → a = b * c⁻¹",
    #     implicit_vars=[A, B, C],
    #     left=A,
    #     right=B * C.inv(),
    #     hyps=[A * C == B],
    # ),
    lean_rule(
        label="eq_neg_add_of_add_eq",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, b + a = c → a = -b + c",
        # implicit_vars=[A, B, C],
        left=A,
        right=-B + C,
        hyps=[B + A == C],
    ),
    # lean_rule(
    #     label="eq_inv_mul_of_mul_eq",
    #     statement="∀ {a b c : ℝ}, b * a = c → a = b⁻¹ * c",
    #     implicit_vars=[A, B, C],
    #     left=A,
    #     right=B.inv() * C,
    #     hyps=[B * A == C],
    # ),
    # lean_rule(
    #     label="inv_mul_eq_of_eq_mul",
    #     statement="∀ {a b c : ℝ}, b = a * c → a⁻¹ * b = c",
    #     implicit_vars=[A, B, C],
    #     left=A.inv() * B,
    #     right=C,
    #     hyps=[B == A * C],
    # ),
    lean_rule(
        label="neg_add_eq_of_eq_add",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, b = a + c → -a + b = c",
        # implicit_vars=[A, B, C],
        left=-A + B,
        right=C,
        hyps=[B == A + C],
    ),
    lean_rule(
        label="add_neg_eq_of_eq_add",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a = c + b → a + -b = c",
        # implicit_vars=[A, B, C],
        left=A + -B,
        right=C,
        hyps=[A == C + B],
    ),
    # lean_rule(
    #     label="mul_inv_eq_of_eq_mul",
    #     statement="∀ {a b c : ℝ}, a = c * b → a * b⁻¹ = c",
    #     implicit_vars=[A, B, C],
    #     left=A * B.inv(),
    #     right=C,
    #     hyps=[A == C * B],
    # ),
    lean_rule(
        label="eq_add_of_add_neg_eq",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a + -c = b → a = b + c",
        # implicit_vars=[A, B, C],
        left=A,
        right=B + C,
        hyps=[A + -C == B],
    ),
    # lean_rule(
    #     label="eq_mul_of_mul_inv_eq",
    #     statement="∀ {a b c : ℝ}, a * c⁻¹ = b → a = b * c",
    #     implicit_vars=[A, B, C],
    #     left=A,
    #     right=B * C,
    #     hyps=[A * C.inv() == B],
    # ),
    # lean_rule(
    #     label="eq_mul_of_inv_mul_eq",
    #     statement="∀ {a b c : ℝ}, b⁻¹ * a = c → a = b * c",
    #     implicit_vars=[A, B, C],
    #     left=A,
    #     right=B * C,
    #     hyps=[B.inv() * A == C],
    # ),
    lean_rule(
        label="eq_add_of_neg_add_eq",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, -b + a = c → a = b + c",
        # implicit_vars=[A, B, C],
        left=A,
        right=B + C,
        hyps=[-B + A == C],
    ),
    # lean_rule(
    #     label="mul_eq_of_eq_inv_mul",
    #     statement="∀ {a b c : ℝ}, b = a⁻¹ * c → a * b = c",
    #     implicit_vars=[A, B, C],
    #     left=A * B,
    #     right=C,
    #     hyps=[B == A.inv() * C],
    # ),
    lean_rule(
        label="add_eq_of_eq_neg_add",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, b = -a + c → a + b = c",
        # implicit_vars=[A, B, C],
        left=A + B,
        right=C,
        hyps=[B == -A + C],
    ),
    # lean_rule(
    #     label="mul_eq_of_eq_mul_inv",
    #     statement="∀ {a b c : ℝ}, a = c * b⁻¹ → a * b = c",
    #     implicit_vars=[A, B, C],
    #     left=A * B,
    #     right=C,
    #     hyps=[A == C * B.inv()],
    # ),
    lean_rule(
        label="add_eq_of_eq_add_neg",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a = c + -b → a + b = c",
        # implicit_vars=[A, B, C],
        left=A + B,
        right=C,
        hyps=[A == C + -B],
    ),
    # lean_rule(
    #     label="mul_self_iff_eq_one",
    #     statement="∀ {a : ℝ}, a * a = a ↔ a = 1",
    #     implicit_vars=[A],
    #     left=A * A == A,
    #     right=A == ONE,
    # ),
    # lean_rule(  # NOT IN OUR MATHLIB
    #     label="add_self_iff_eq_zero",
    #     statement="∀ {a : ℝ}, a + a = a ↔ a = 0",
    #     implicit_vars=[A],
    #     left=A + A == A,
    #     right=A == ZERO,
    # ),
    # lean_rule(
    #     label="inv_eq_one",
    #     statement="∀ {a : ℝ}, a⁻¹ = 1 ↔ a = 1",
    #     implicit_vars=[A],
    #     left=A.inv() == ONE,
    #     right=A == ONE,
    # ),
    lean_rule(
        label="neg_eq_zero",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a : G}, -a = 0 ↔ a = 0",
        # implicit_vars=[A],
        left=-A == ZERO,
        right=A == ZERO,
    ),
    # lean_rule(
    #     label="inv_ne_one",
    #     statement="∀ {a : ℝ}, a⁻¹ ≠ 1 ↔ a ≠ 1",
    #     implicit_vars=[A],
    #     left=A.inv() != ONE,
    #     right=A != ONE,
    # ),
    lean_rule(
        label="neg_ne_zero",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a : G}, -a ≠ 0 ↔ a ≠ 0",
        # implicit_vars=[A],
        left=-A != ZERO,
        right=A != ZERO,
    ),
    # lean_rule(
    #     label="eq_inv_iff_eq_inv",
    #     statement="∀ {a b : ℝ}, a = b⁻¹ ↔ b = a⁻¹",
    #     implicit_vars=[A, B],
    #     left=A == B.inv(),
    #     right=B == A.inv(),
    # ),
    lean_rule(
        label="eq_neg_iff_eq_neg",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, a = -b ↔ b = -a",
        # implicit_vars=[A, B],
        left=A == -B,
        right=B == -A,
    ),
    lean_rule(
        label="neg_eq_iff_neg_eq",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, -a = b ↔ -b = a",
        # implicit_vars=[A, B],
        left=-A == B,
        right=-B == A,
    ),
    # lean_rule(
    #     label="inv_eq_iff_inv_eq",
    #     statement="∀ {a b : ℝ}, a⁻¹ = b ↔ b⁻¹ = a",
    #     implicit_vars=[A, B],
    #     left=A.inv() == B,
    #     right=B.inv() == A,
    # ),
    # lean_rule(
    #     label="mul_eq_one_iff_eq_inv",
    #     statement="∀ {a b : ℝ}, a * b = 1 ↔ a = b⁻¹",
    #     implicit_vars=[A, B],
    #     left=A * B == ONE,
    #     right=A == B.inv(),
    # ),
    lean_rule(
        label="add_eq_zero_iff_eq_neg",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, a + b = 0 ↔ a = -b",
        # implicit_vars=[A, B],
        left=A + B == ZERO,
        right=A == -B,
    ),
    # lean_rule(
    #     label="mul_eq_one_iff_inv_eq",
    #     statement="∀ {a b : ℝ}, a * b = 1 ↔ a⁻¹ = b",
    #     implicit_vars=[A, B],
    #     left=A * B == ONE,
    #     right=A.inv() == B,
    # ),
    lean_rule(
        label="add_eq_zero_iff_neg_eq",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, a + b = 0 ↔ -a = b",
        # implicit_vars=[A, B],
        left=A + B == ZERO,
        right=-A == B,
    ),
    # lean_rule(
    #     label="eq_inv_iff_mul_eq_one",
    #     statement="∀ {a b : ℝ}, a = b⁻¹ ↔ a * b = 1",
    #     implicit_vars=[A, B],
    #     left=A == B.inv(),
    #     right=A * B == ONE,
    # ),
    lean_rule(
        label="eq_neg_iff_add_eq_zero",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, a = -b ↔ a + b = 0",
        # implicit_vars=[A, B],
        left=A == -B,
        right=A + B == ZERO,
    ),
    lean_rule(
        label="neg_eq_iff_add_eq_zero",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, -a = b ↔ a + b = 0",
        # implicit_vars=[A, B],
        left=-A == B,
        right=A + B == ZERO,
    ),
    # lean_rule(
    #     label="inv_eq_iff_mul_eq_one",
    #     statement="∀ {a b : ℝ}, a⁻¹ = b ↔ a * b = 1",
    #     implicit_vars=[A, B],
    #     left=A.inv() == B,
    #     right=A * B == ONE,
    # ),
    lean_rule(
        label="eq_add_neg_iff_add_eq",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a = b + -c ↔ a + c = b",
        # implicit_vars=[A, B, C],
        left=A == B + -C,
        right=A + C == B,
    ),
    # lean_rule(
    #     label="eq_mul_inv_iff_mul_eq",
    #     statement="∀ {a b c : ℝ}, a = b * c⁻¹ ↔ a * c = b",
    #     implicit_vars=[A, B, C],
    #     left=A == B * C.inv(),
    #     right=A * C == B,
    # ),
    # lean_rule(
    #     label="eq_inv_mul_iff_mul_eq",
    #     statement="∀ {a b c : ℝ}, a = b⁻¹ * c ↔ b * a = c",
    #     implicit_vars=[A, B, C],
    #     left=A == B.inv() * C,
    #     right=B * A == C,
    # ),
    lean_rule(
        label="eq_neg_add_iff_add_eq",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a = -b + c ↔ b + a = c",
        # implicit_vars=[A, B, C],
        left=A == -B + C,
        right=B + A == C,
    ),
    lean_rule(
        label="neg_add_eq_iff_eq_add",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, -a + b = c ↔ b = a + c",
        # implicit_vars=[A, B, C],
        left=-A + B == C,
        right=B == A + C,
    ),
    # lean_rule(
    #     label="inv_mul_eq_iff_eq_mul",
    #     statement="∀ {a b c : ℝ}, a⁻¹ * b = c ↔ b = a * c",
    #     implicit_vars=[A, B, C],
    #     left=A.inv() * B == C,
    #     right=B == A * C,
    # ),
    lean_rule(
        label="add_neg_eq_iff_eq_add",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a + -b = c ↔ a = c + b",
        # implicit_vars=[A, B, C],
        left=A + -B == C,
        right=A == C + B,
    ),
    # lean_rule(
    #     label="mul_inv_eq_iff_eq_mul",
    #     statement="∀ {a b c : ℝ}, a * b⁻¹ = c ↔ a = c * b",
    #     implicit_vars=[A, B, C],
    #     left=A * B.inv() == C,
    #     right=A == C * B,
    # ),
    # lean_rule(
    #     label="mul_inv_eq_one",
    #     statement="∀ {a b : ℝ}, a * b⁻¹ = 1 ↔ a = b",
    #     implicit_vars=[A, B],
    #     left=A * B.inv() == ONE,
    #     right=A == B,
    # ),
    lean_rule(
        label="add_neg_eq_zero",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, a + -b = 0 ↔ a = b",
        # implicit_vars=[A, B],
        left=A + -B == ZERO,
        right=A == B,
    ),
    # lean_rule(
    #     label="inv_mul_eq_one",
    #     statement="∀ {a b : ℝ}, a⁻¹ * b = 1 ↔ a = b",
    #     implicit_vars=[A, B],
    #     left=A.inv() * B == ONE,
    #     right=A == B,
    # ),
    lean_rule(
        label="neg_add_eq_zero",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, -a + b = 0 ↔ a = b",
        # implicit_vars=[A, B],
        left=-A + B == ZERO,
        right=A == B,
    ),
    lean_rule(
        label="add_left_eq_self",
        statement="∀ {M : Type u} [_inst_1 : add_right_cancel_monoid M] {a b : M}, a + b = b ↔ a = 0",
        # implicit_vars=[A, B],
        left=A + B == B,
        right=A == ZERO,
    ),
    # lean_rule(
    #     label="mul_left_eq_self",
    #     statement="∀ {a b : ℝ}, a * b = b ↔ a = 1",
    #     implicit_vars=[A, B],
    #     left=A * B == B,
    #     right=A == ONE,
    # ),
    lean_rule(
        label="add_right_eq_self",
        statement="∀ {M : Type u} [_inst_1 : add_left_cancel_monoid M] {a b : M}, a + b = a ↔ b = 0",
        # implicit_vars=[A, B],
        left=A + B == A,
        right=B == ZERO,
    ),
    # lean_rule(
    #     label="mul_right_eq_self",
    #     statement="∀ {a b : ℝ}, a * b = a ↔ b = 1",
    #     implicit_vars=[A, B],
    #     left=A * B == A,
    #     right=B == ONE,
    # ),
    lean_rule(
        label="sub_self",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a : G), a - a = 0",
        left=A - A,
        right=ZERO,
    ),
    lean_rule(
        label="sub_add_cancel",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a b : G), a - b + b = a",
        left=A - B + B,
        right=A,
    ),
    lean_rule(
        label="add_sub_cancel",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a b : G), a + b - b = a",
        left=A + B - B,
        right=A,
    ),
    lean_rule(
        label="add_sub_assoc",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a b c : G), a + b - c = a + (b - c)",
        left=A + B - C,
        right=A + (B - C),
    ),
    lean_rule(
        label="eq_of_sub_eq_zero",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, a - b = 0 → a = b",
        # implicit_vars=[A, B],
        left=A,
        right=B,
        hyps=[A - B == ZERO],
    ),
    lean_rule(
        label="sub_eq_zero_of_eq",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, a = b → a - b = 0",
        # implicit_vars=[A, B],
        left=A - B,
        right=ZERO,
        hyps=[A == B],
    ),
    # lean_rule(
    #     label="sub_eq_zero_iff_eq",
    #     statement="∀ {a b : ℝ}, a - b = 0 ↔ a = b",
    #     implicit_vars=[A, B],
    #     left=A - B == ZERO,
    #     right=A == B,
    # ),
    lean_rule(
        label="zero_sub",
        statement="∀ {G : Type u} [_inst_1 : sub_neg_monoid G] (a : G), 0 - a = -a",
        left=ZERO - A,
        right=-A,
    ),
    lean_rule(
        label="sub_zero",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a : G), a - 0 = a",
        left=A - ZERO,
        right=A,
    ),
    lean_rule(
        label="sub_ne_zero_of_ne",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, a ≠ b → a - b ≠ 0",
        # implicit_vars=[A, B],
        node=A - B != ZERO,
        hyps=[A != B],
    ),
    lean_rule(
        label="sub_neg_eq_add",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a b : G), a - -b = a + b",
        left=A - (-B),
        right=A + B,
    ),
    lean_rule(
        label="neg_sub",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a b : G), -(a - b) = b - a",
        left=-(A - B),
        right=B - A,
    ),
    lean_rule(
        label="add_sub",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a b c : G), a + (b - c) = a + b - c",
        left=A + (B - C),
        right=A + B - C,
    ),
    lean_rule(
        label="sub_add_eq_sub_sub_swap",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a b c : G), a - (b + c) = a - c - b",
        left=A - (B + C),
        right=A - C - B,
    ),
    lean_rule(
        label="add_sub_add_right_eq_sub",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a b c : G), a + c - (b + c) = a - b",
        left=A + C - (B + C),
        right=A - B,
    ),
    lean_rule(
        label="eq_sub_of_add_eq",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a + c = b → a = b - c",
        # implicit_vars=[A, B, C],
        left=A,
        right=B - C,
        hyps=[A + C == B],
    ),
    lean_rule(
        label="sub_eq_of_eq_add",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a = c + b → a - b = c",
        # implicit_vars=[A, B, C],
        left=A - B,
        right=C,
        hyps=[A == C + B],
    ),
    lean_rule(
        label="eq_add_of_sub_eq",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a - c = b → a = b + c",
        # implicit_vars=[A, B, C],
        left=A,
        right=B + C,
        hyps=[A - C == B],
    ),
    lean_rule(
        label="add_eq_of_eq_sub",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a = c - b → a + b = c",
        # implicit_vars=[A, B, C],
        left=A + B,
        right=C,
        hyps=[A == C - B],
    ),
    lean_rule(
        label="sub_right_inj",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a - b = a - c ↔ b = c",
        # implicit_vars=[A, B, C],
        left=A - B == A - C,
        right=B == C,
    ),
    lean_rule(
        label="sub_left_inj",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, b - a = c - a ↔ b = c",
        # implicit_vars=[A, B, C],
        left=B - A == C - A,
        right=B == C,
    ),
    lean_rule(
        label="sub_add_sub_cancel",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a b c : G), a - b + (b - c) = a - c",
        left=A - B + (B - C),
        right=A - C,
    ),
    lean_rule(
        label="sub_sub_sub_cancel_right",
        statement="∀ {G : Type u} [_inst_1 : add_group G] (a b c : G), a - c - (b - c) = a - b",
        left=A - C - (B - C),
        right=A - B,
    ),
    lean_rule(
        label="sub_sub_assoc_swap",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a - (b - c) = a + c - b",
        # implicit_vars=[A, B, C],
        left=A - (B - C),
        right=A + C - B,
    ),
    lean_rule(
        label="sub_eq_zero",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, a - b = 0 ↔ a = b",
        # implicit_vars=[A, B],
        left=A - B == ZERO,
        right=A == B,
    ),
    lean_rule(
        label="sub_ne_zero",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, a - b ≠ 0 ↔ a ≠ b",
        # implicit_vars=[A, B],
        left=A - B != ZERO,
        right=A != B,
    ),
    lean_rule(
        label="eq_sub_iff_add_eq",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a = b - c ↔ a + c = b",
        # implicit_vars=[A, B, C],
        left=A == B - C,
        right=A + C == B,
    ),
    lean_rule(
        label="sub_eq_iff_eq_add",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c : G}, a - b = c ↔ a = c + b",
        # implicit_vars=[A, B, C],
        left=A - B == C,
        right=A == C + B,
    ),
    lean_rule(
        label="eq_iff_eq_of_sub_eq_sub",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b c d : G}, a - b = c - d → (a = b ↔ c = d)",
        # implicit_vars=[A, B, C, D],
        left=A == B,
        right=C == D,
        hyps=[A - B == C - D],
    ),
    # lean_rule(
    #     label="mul_inv",
    #     statement="∀ (a b : ℝ), (a * b)⁻¹ = a⁻¹ * b⁻¹",
    #     left=(A * B).inv(),
    #     right=A.inv() * B.inv(),
    # ),
    lean_rule(
        label="neg_add",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b : G), -(a + b) = -a + -b",
        left=-(A + B),
        right=-A + -B,
    ),
    lean_rule(
        label="sub_add_eq_sub_sub",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b c : G), a - (b + c) = a - b - c",
        left=A - (B + C),
        right=A - B - C,
    ),
    lean_rule(
        label="neg_add_eq_sub",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b : G), -a + b = b - a",
        left=-A + B,
        right=B - A,
    ),
    lean_rule(
        label="sub_add_eq_add_sub",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b c : G), a - b + c = a + c - b",
        left=A - B + C,
        right=A + C - B,
    ),
    lean_rule(
        label="sub_sub",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b c : G), a - b - c = a - (b + c)",
        left=A - B - C,
        right=A - (B + C),
    ),
    lean_rule(
        label="sub_add",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b c : G), a - b + c = a - (b - c)",
        left=A - B + C,
        right=A - (B - C),
    ),
    lean_rule(
        label="add_sub_add_left_eq_sub",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b c : G), c + a - (c + b) = a - b",
        left=C + A - (C + B),
        right=A - B,
    ),
    lean_rule(
        label="eq_sub_of_add_eq'",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] {a b c : G}, c + a = b → a = b - c",
        # implicit_vars=[A, B, C],
        left=A,
        right=B - C,
        hyps=[C + A == B],
    ),
    lean_rule(
        label="sub_eq_of_eq_add'",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] {a b c : G}, a = b + c → a - b = c",
        # implicit_vars=[A, B, C],
        left=A - B,
        right=C,
        hyps=[A == B + C],
    ),
    lean_rule(
        label="eq_add_of_sub_eq'",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] {a b c : G}, a - b = c → a = b + c",
        # implicit_vars=[A, B, C],
        left=A,
        right=B + C,
        hyps=[A - B == C],
    ),
    lean_rule(
        label="add_eq_of_eq_sub'",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] {a b c : G}, b = c - a → a + b = c",
        # implicit_vars=[A, B, C],
        left=A + B,
        right=C,
        hyps=[B == C - A],
    ),
    lean_rule(
        label="sub_sub_self",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b : G), a - (a - b) = b",
        left=A - (A - B),
        right=B,
    ),
    lean_rule(
        label="add_sub_comm",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b c d : G), a + b - (c + d) = a - c + (b - d)",
        left=A + B - (C + D),
        right=A - C + (B - D),
    ),
    lean_rule(
        label="sub_eq_sub_add_sub",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b c : G), a - b = c - b + (a - c)",
        left=A - B,
        right=C - B + (A - C),
    ),
    lean_rule(
        label="neg_neg_sub_neg",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b : G), -(-a - -b) = a - b",
        left=-(-A - -B),
        right=A - B,
    ),
    lean_rule(
        label="sub_sub_cancel",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b : G), a - (a - b) = b",
        left=A - (A - B),
        right=B,
    ),
    lean_rule(
        label="sub_eq_neg_add",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b : G), a - b = -b + a",
        left=A - B,
        right=-B + A,
    ),
    lean_rule(
        label="neg_add'",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b : G), -(a + b) = -a - b",
        left=-(A + B),
        right=-A - B,
    ),
    lean_rule(
        label="neg_sub_neg",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b : G), -a - -b = b - a",
        left=-A - -B,
        right=B - A,
    ),
    lean_rule(
        label="eq_sub_iff_add_eq'",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] {a b c : G}, a = b - c ↔ c + a = b",
        # implicit_vars=[A, B, C],
        left=A == B - C,
        right=C + A == B,
    ),
    lean_rule(
        label="sub_eq_iff_eq_add'",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] {a b c : G}, a - b = c ↔ a = b + c",
        # implicit_vars=[A, B, C],
        left=A - B == C,
        right=A == B + C,
    ),
    lean_rule(
        label="add_sub_cancel'",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b : G), a + b - a = b",
        left=A + B - A,
        right=B,
    ),
    lean_rule(
        label="add_sub_cancel'_right",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b : G), a + (b - a) = b",
        left=A + (B - A),
        right=B,
    ),
    lean_rule(
        label="add_add_neg_cancel'_right",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b : G), a + (b + -a) = b",
        left=A + (B + -A),
        right=B,
    ),
    lean_rule(
        label="sub_right_comm",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b c : G), a - b - c = a - c - b",
        left=A - B - C,
        right=A - C - B,
    ),
    lean_rule(
        label="add_add_sub_cancel",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b c : G), a + c + (b - c) = a + b",
        left=A + C + (B - C),
        right=A + B,
    ),
    lean_rule(
        label="sub_add_add_cancel",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b c : G), a - c + (b + c) = a + b",
        left=A - C + (B + C),
        right=A + B,
    ),
    lean_rule(
        label="sub_add_sub_cancel'",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b c : G), a - b + (c - a) = c - b",
        left=A - B + (C - A),
        right=C - B,
    ),
    lean_rule(
        label="add_sub_sub_cancel",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b c : G), a + b - (a - c) = b + c",
        left=A + B - (A - C),
        right=B + C,
    ),
    lean_rule(
        label="sub_sub_sub_cancel_left",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] (a b c : G), c - a - (c - b) = b - a",
        left=C - A - (C - B),
        right=B - A,
    ),
    lean_rule(
        label="sub_eq_sub_iff_add_eq_add",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] {a b c d : G}, a - b = c - d ↔ a + d = c + b",
        # implicit_vars=[A, B, C, D],
        left=A - B == C - D,
        right=A + D == C + B,
    ),
    lean_rule(
        label="sub_eq_sub_iff_sub_eq_sub",
        statement="∀ {G : Type u} [_inst_1 : add_comm_group G] {a b c d : G}, a - b = c - d ↔ a - c = b - d",
        # implicit_vars=[A, B, C, D],
        left=A - B == C - D,
        right=A - C == B - D,
    ),
    lean_rule(
        label="eq_zero_iff_eq_zero_of_add_eq_zero",
        statement="∀ {M : Type u} [_inst_1 : add_zero_class M] {a b : M}, a + b = 0 → (a = 0 ↔ b = 0)",
        # implicit_vars=[A, B],
        left=A == ZERO,
        right=B == ZERO,
        hyps=[A + B == ZERO],
    ),
    lean_rule(
        label="eq_one_iff_eq_one_of_mul_eq_one",
        statement="∀ {M : Type u} [_inst_1 : mul_one_class M] {a b : M}, a * b = 1 → (a = 1 ↔ b = 1)",
        # implicit_vars=[A, B],
        left=A == ONE,
        right=B == ONE,
        hyps=[A * B == ONE],
    ),
    lean_rule(
        label="self_eq_add_right",
        statement="∀ {M : Type u} [_inst_1 : add_left_cancel_monoid M] {a b : M}, a = a + b ↔ b = 0",
        # implicit_vars=[A, B],
        left=A == A + B,
        right=B == ZERO,
    ),
    lean_rule(
        label="self_eq_add_left",
        statement="∀ {M : Type u} [_inst_1 : add_right_cancel_monoid M] {a b : M}, b = a + b ↔ a = 0",
        # implicit_vars=[A, B],
        left=B == A + B,
        right=A == ZERO,
    ),
    lean_rule(
        label="neg_eq_zero_sub",
        statement="∀ {G : Type u} [_inst_1 : sub_neg_monoid G] (x : G), -x = 0 - x",
        left=-A,
        right=ZERO - A,
    ),
    lean_rule(
        label="add_zero_sub",
        statement="∀ {G : Type u} [_inst_1 : sub_neg_monoid G] (x y : G), x + (0 - y) = x - y",
        left=A + (ZERO - B),
        right=A - B,
    ),
    lean_rule(
        label="zero_eq_neg",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a : G}, 0 = -a ↔ a = 0",
        # implicit_vars=[A],
        left=ZERO == -A,
        right=A == ZERO,
    ),
    # lean_rule(
    #     label="div_one'",
    #     statement="∀ {G : Type u} [_inst_1 : group G] (a : G), a / 1 = a",
    #     left=A / ONE,
    #     right=A,
    # ),
    lean_rule(
        label="sub_eq_self",
        statement="∀ {G : Type u} [_inst_1 : add_group G] {a b : G}, a - b = a ↔ b = 0",
        # implicit_vars=[A, B],
        left=A - B == A,
        right=B == ZERO,
    ),
]

LEAN_GROUPS_WITH_ZERO_RULES = [
    lean_rule(
        label="mul_eq_zero_of_left",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_class M₀] {a : M₀}, a = 0 → ∀ (b : M₀), a * b = 0",
        # implicit_vars=[A],
        left=A * B,
        right=ZERO,
        hyps=[A == ZERO],
        # hyp_first=True,
    ),
    lean_rule(
        label="mul_eq_zero_of_right",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_class M₀] {b : M₀} (a : M₀), b = 0 → a * b = 0",
        # implicit_vars=[A],
        left=B * A,
        right=ZERO,
        hyps=[A == ZERO],
    ),
    lean_rule(
        label="eq_zero_of_mul_self_eq_zero",
        statement="∀ {M₀ : Type u_1} [_inst_1 : has_mul M₀] [_inst_2 : has_zero M₀] [_inst_3 : no_zero_divisors M₀] {a : M₀}, a * a = 0 → a = 0",
        # implicit_vars=[A],
        left=A,
        right=ZERO,
        hyps=[A * A == ZERO],
    ),
    lean_rule(
        label="mul_ne_zero",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_class M₀] [_inst_2 : no_zero_divisors M₀] {a b : M₀}, a ≠ 0 → b ≠ 0 → a * b ≠ 0",
        # implicit_vars=[A, B],
        node=A * B != ZERO,
        hyps=[A != ZERO, B != ZERO],
    ),
    lean_rule(
        label="mul_eq_zero_comm",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_class M₀] [_inst_2 : no_zero_divisors M₀] {a b : M₀}, a * b = 0 ↔ b * a = 0",
        # implicit_vars=[A, B],
        left=A * B == ZERO,
        right=B * A == ZERO,
    ),
    lean_rule(
        label="mul_ne_zero_comm",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_class M₀] [_inst_2 : no_zero_divisors M₀] {a b : M₀}, a * b ≠ 0 ↔ b * a ≠ 0",
        # implicit_vars=[A, B],
        left=A * B != ZERO,
        right=B * A != ZERO,
    ),
    lean_rule(
        label="mul_self_eq_zero",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_class M₀] [_inst_2 : no_zero_divisors M₀] {a : M₀}, a * a = 0 ↔ a = 0",
        # implicit_vars=[A],
        left=A * A == ZERO,
        right=A == ZERO,
    ),
    lean_rule(
        label="zero_eq_mul_self",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_class M₀] [_inst_2 : no_zero_divisors M₀] {a : M₀}, 0 = a * a ↔ a = 0",
        # implicit_vars=[A],
        left=ZERO == A * A,
        right=A == ZERO,
    ),
    lean_rule(
        label="eq_zero_of_zero_eq_one",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_one_class M₀], 0 = 1 → ∀ (a : M₀), a = 0",
        left=A,
        right=ZERO,
        hyps=[ZERO == ONE],
        # hyp_first=True,
    ),
    lean_rule(
        label="eq_of_zero_eq_one",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_one_class M₀], 0 = 1 → ∀ (a b : M₀), a = b",
        left=A,
        right=B,
        hyps=[ZERO == ONE],
        # hyp_first=True,
    ),
    lean_rule(
        label="zero_ne_one",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_one_class M₀] [_inst_2 : nontrivial M₀], 0 ≠ 1",
        node=ZERO != ONE,
    ),
    lean_rule(
        label="one_ne_zero",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_one_class M₀] [_inst_2 : nontrivial M₀], 1 ≠ 0",
        node=ONE != ZERO,
    ),
    lean_rule(
        label="ne_zero_of_eq_one",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_one_class M₀] [_inst_2 : nontrivial M₀] {a : M₀}, a = 1 → a ≠ 0",
        # implicit_vars=[A],
        node=A != ZERO,
        hyps=[A == ONE],
    ),
    lean_rule(
        label="left_ne_zero_of_mul_eq_one",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_one_class M₀] [_inst_2 : nontrivial M₀] {a b : M₀}, a * b = 1 → a ≠ 0",
        # implicit_vars=[A, B],
        node=A != ZERO,
        hyps=[A * B == ONE],
    ),
    lean_rule(
        label="right_ne_zero_of_mul_eq_one",
        statement="∀ {M₀ : Type u_1} [_inst_1 : mul_zero_one_class M₀] [_inst_2 : nontrivial M₀] {a b : M₀}, a * b = 1 → b ≠ 0",
        # implicit_vars=[A, B],
        node=B != ZERO,
        hyps=[A * B == ONE],
    ),
    lean_rule(
        label="mul_left_inj'",
        statement="∀ {M₀ : Type u_1} [_inst_1 : cancel_monoid_with_zero M₀] {a b c : M₀}, c ≠ 0 → (a * c = b * c ↔ a = b)",
        # implicit_vars=[A, B, C],
        left=A * C == B * C,
        right=A == B,
        hyps=[C != ZERO],
    ),
    lean_rule(
        label="mul_right_inj'",
        statement="∀ {M₀ : Type u_1} [_inst_1 : cancel_monoid_with_zero M₀] {a b c : M₀}, a ≠ 0 → (a * b = a * c ↔ b = c)",
        # implicit_vars=[A, B, C],
        left=A * B == A * C,
        right=B == C,
        hyps=[A != ZERO],
    ),
    lean_rule(
        label="eq_zero_of_mul_eq_self_right",
        statement="∀ {M₀ : Type u_1} [_inst_1 : cancel_monoid_with_zero M₀] {a b : M₀}, b ≠ 1 → a * b = a → a = 0",
        # implicit_vars=[A, B],
        left=A,
        right=ZERO,
        hyps=[B != ONE, A * B == A],
    ),
    lean_rule(
        label="eq_zero_of_mul_eq_self_left",
        statement="∀ {M₀ : Type u_1} [_inst_1 : cancel_monoid_with_zero M₀] {a b : M₀}, b ≠ 1 → b * a = a → a = 0",
        # implicit_vars=[A, B],
        left=A,
        right=ZERO,
        hyps=[B != ONE, B * A == A],
    ),
    lean_rule(
        label="div_self",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {a : G₀}, a ≠ 0 → a / a = 1",
        # implicit_vars=[A],
        left=A / A,
        right=ONE,
        hyps=[A != ZERO],
    ),
    lean_rule(
        label="div_one",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] (a : G₀), a / 1 = a",
        left=A / ONE,
        right=A,
    ),
    lean_rule(
        label="div_mul_cancel",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] (a : G₀) {b : G₀}, b ≠ 0 → a / b * b = a",
        # implicit_vars=[B],
        left=(A / B) * B,
        right=A,
        hyps=[B != ZERO],
    ),
    lean_rule(
        label="mul_div_cancel",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] (a : G₀) {b : G₀}, b ≠ 0 → a * b / b = a",
        # implicit_vars=[B],
        left=A * B / B,
        right=A,
        hyps=[B != ZERO],
    ),
    lean_rule(
        label="mul_one_div_cancel",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {a : G₀}, a ≠ 0 → a * (1 / a) = 1",
        # implicit_vars=[A],
        left=A * (ONE / A),
        right=ONE,
        hyps=[A != ZERO],
    ),
    lean_rule(
        label="one_div_mul_cancel",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {a : G₀}, a ≠ 0 → 1 / a * a = 1",
        # implicit_vars=[A],
        left=(ONE / A) * A,
        right=ONE,
        hyps=[A != ZERO],
    ),
    lean_rule(
        label="one_div_one",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀], 1 / 1 = 1",
        left=ONE / ONE,
        right=ONE,
    ),
    lean_rule(
        label="one_div_ne_zero",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {a : G₀}, a ≠ 0 → 1 / a ≠ 0",
        # implicit_vars=[A],
        node=ONE / A != ZERO,
        hyps=[A != ZERO],
    ),
    lean_rule(
        label="eq_one_div_of_mul_eq_one",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {a b : G₀}, a * b = 1 → b = 1 / a",
        # implicit_vars=[A, B],
        left=B,
        right=ONE / A,
        hyps=[A * B == ONE],
    ),
    lean_rule(
        label="eq_one_div_of_mul_eq_one_left",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {a b : G₀}, b * a = 1 → b = 1 / a",
        # implicit_vars=[A, B],
        left=B,
        right=ONE / A,
        hyps=[B * A == ONE],
    ),
    lean_rule(
        label="div_ne_zero",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {a b : G₀}, a ≠ 0 → b ≠ 0 → a / b ≠ 0",
        # implicit_vars=[A, B],
        node=A / B != ZERO,
        hyps=[A != ZERO, B != ZERO],
    ),
    lean_rule(
        label="div_left_inj'",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {a b c : G₀}, c ≠ 0 → (a / c = b / c ↔ a = b)",
        # implicit_vars=[A, B, C],
        left=A / C == B / C,
        right=A == B,
        hyps=[C != ZERO],
    ),
    lean_rule(
        label="div_eq_iff_mul_eq",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {a b c : G₀}, b ≠ 0 → (a / b = c ↔ c * b = a)",
        # implicit_vars=[A, B, C],
        left=A / B == C,
        right=C * B == A,
        hyps=[B != ZERO],
    ),
    lean_rule(
        label="eq_div_iff_mul_eq",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {a b c : G₀}, c ≠ 0 → (a = b / c ↔ a * c = b)",
        # implicit_vars=[A, B, C],
        left=A == B / C,
        right=A * C == B,
        hyps=[C != ZERO],
    ),
    # TODO fix this weird hyp_first in implicit mode
    # lean_rule(
    #     label="div_eq_of_eq_mul",
    #     statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {x : G₀}, x ≠ 0 → ∀ {y z : G₀}, y = z * x → y / x = z",
    #     implicit_vars=[A, B, C],
    #     left=B / A,
    #     right=C,
    #     hyps=[A != ZERO, B == C * A],
    #     hyp_first=True,
    # ),
    # lean_rule(
    #     label="eq_div_of_mul_eq",
    #     statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {x : G₀}, x ≠ 0 → ∀ {y z : G₀}, z * x = y → z = y / x",
    #     implicit_vars=[A, B, C],
    #     left=C,
    #     right=B / A,
    #     hyps=[A != ZERO, C * A == B],
    #     hyp_first=True,
    # ),
    lean_rule(
        label="div_eq_one_iff_eq",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {a b : G₀}, b ≠ 0 → (a / b = 1 ↔ a = b)",
        # implicit_vars=[A, B],
        left=A / B == ONE,
        right=A == B,
        hyps=[B != ZERO],
    ),
    lean_rule(
        label="mul_mul_div",
        statement="∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] (a : G₀) {b : G₀}, b ≠ 0 → a = a * b * (1 / b)",
        # implicit_vars=[B],
        left=A,
        right=(A * B) * (ONE / B),
        hyps=[B != ZERO],
        # mandatory_vars=[A],
    ),
    lean_rule(
        label="mul_div_cancel_left",
        statement="∀ {G₀ : Type u_2} [_inst_1 : comm_group_with_zero G₀] {a : G₀} (b : G₀), a ≠ 0 → a * b / a = b",
        # implicit_vars=[A],
        left=A * B / A,
        right=B,
        hyps=[A != ZERO],
    ),
    lean_rule(
        label="mul_div_cancel'",
        statement="∀ {G₀ : Type u_2} [_inst_1 : comm_group_with_zero G₀] (a : G₀) {b : G₀}, b ≠ 0 → b * (a / b) = a",
        # implicit_vars=[B],
        left=B * (A / B),
        right=A,
        hyps=[B != ZERO],
    ),
    lean_rule(
        label="mul_eq_mul_of_div_eq_div",
        statement="∀ {G₀ : Type u_2} [_inst_1 : comm_group_with_zero G₀] (a : G₀) {b : G₀} (c : G₀) {d : G₀}, b ≠ 0 → d ≠ 0 → a / b = c / d → a * d = c * b",
        # implicit_vars=[B, D],
        left=A * D,
        right=C * B,
        hyps=[B != ZERO, D != ZERO, A / B == C / D],
    ),
    lean_rule(
        label="div_eq_div_iff",
        statement="∀ {G₀ : Type u_2} [_inst_1 : comm_group_with_zero G₀] {a b c d : G₀}, b ≠ 0 → d ≠ 0 → (a / b = c / d ↔ a * d = c * b)",
        # implicit_vars=[A, B, C, D],
        left=A / B == C / D,
        right=A * D == C * B,
        hyps=[B != ZERO, D != ZERO],
    ),
    lean_rule(
        label="div_eq_iff",
        statement="∀ {G₀ : Type u_2} [_inst_1 : comm_group_with_zero G₀] {a b c : G₀}, b ≠ 0 → (a / b = c ↔ a = c * b)",
        # implicit_vars=[A, B, C],
        left=A / B == C,
        right=A == C * B,
        hyps=[B != ZERO],
    ),
    lean_rule(
        label="eq_div_iff",
        statement="∀ {G₀ : Type u_2} [_inst_1 : comm_group_with_zero G₀] {a b c : G₀}, b ≠ 0 → (c = a / b ↔ c * b = a)",
        # implicit_vars=[A, B, C],
        left=C == A / B,
        right=C * B == A,
        hyps=[B != ZERO],
    ),
]

LEAN_MISC_RULES = [
    lean_rule(
        label="neg_add_cancel_comm",
        statement="∀ {G : Type u_1} [_inst_1 : add_comm_group G] (a b : G), -a + b + a = b",
        left=-A + B + A,
        right=B,
    ),
    lean_rule(
        label="sq",
        statement="∀ {M : Type u} [_inst_1 : monoid M] (a : M), a ^ 2 = a * a",
        left=A ** 2,
        right=A * A,
    ),
    lean_rule(
        label="pow_two_sub_pow_two",
        statement="∀ {R : Type u_1} [_inst_1 : comm_ring R] (a b : R), a ^ 2 - b ^ 2 = (a + b) * (a - b)",
        left=A ** 2 - B ** 2,
        right=(A + B) * (A - B),
    ),
    lean_rule(
        label="add_pow_two",
        statement="∀ {R : Type u₁} [_inst_1 : comm_semiring R] (a b : R), (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2",
        left=(A + B) ** 2,
        right=A ** 2 + (INode(2) * A) * B + B ** 2,
    ),
    lean_rule(
        label="sq_nonneg",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] (a : R), 0 ≤ a ^ 2",
        node=ZERO <= A ** 2,
    ),
    lean_rule(
        label="sq_pos_of_ne_zero",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] (a : R), a ≠ 0 → 0 < a ^ 2",
        node=ZERO < A ** 2,
        hyps=[A != ZERO],
    ),
    lean_rule(
        label="sq_abs",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] (x : R), abs x ^ 2 = x ^ 2",
        left=abs(A) ** 2,
        right=A ** 2,
    ),
    lean_rule(
        label="sq_lt_sq",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] {x y : R}, abs x < y → x ^ 2 < y ^ 2",
        # implicit_vars=[A, B],
        node=A ** 2 < B ** 2,
        hyps=[abs(A) < B],
    ),
    lean_rule(
        label="sq_le_sq",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] {x y : R}, abs x ≤ abs y → x ^ 2 ≤ y ^ 2",
        # implicit_vars=[A, B],
        node=A ** 2 <= B ** 2,
        hyps=[abs(A) <= abs(B)],
    ),
    lean_rule(
        label="abs_lt_abs_of_sq_lt_sq",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] {x y : R}, x ^ 2 < y ^ 2 → abs x < abs y",
        # implicit_vars=[A, B],
        node=abs(A) < abs(B),
        hyps=[A ** 2 < B ** 2],
    ),
    lean_rule(
        label="abs_lt_of_sq_lt_sq",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] {x y : R}, x ^ 2 < y ^ 2 → 0 ≤ y → abs x < y",
        # implicit_vars=[A, B],
        node=abs(A) < B,
        hyps=[A ** 2 < B ** 2, ZERO <= B],
    ),
    lean_rule(
        label="abs_le_abs_of_sq_le_sq",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] {x y : R}, x ^ 2 ≤ y ^ 2 → abs x ≤ abs y",
        # implicit_vars=[A, B],
        node=abs(A) <= abs(B),
        hyps=[A ** 2 <= B ** 2],
    ),
    lean_rule(
        label="eq_of_sq_eq_sq",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_comm_ring R] {a b : R}, 0 ≤ a → 0 ≤ b → (a ^ 2 = b ^ 2 ↔ a = b)",
        # implicit_vars=[A, B],
        left=A ** 2 == B ** 2,
        right=A == B,
        hyps=[ZERO <= A, ZERO <= B],
    ),
    lean_rule(
        label="two_mul_le_add_sq",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_comm_ring R] (a b : R), 2 * a * b ≤ a ^ 2 + b ^ 2",
        node=(INode(2) * A) * B <= A ** 2 + B ** 2,
    ),
    lean_rule(
        label="neg_sq",
        statement="∀ {α : Type u_1} [_inst_1 : ring α] (z : α), (-z) ^ 2 = z ^ 2",
        left=(-A) ** 2,
        right=A ** 2,
    ),
    lean_rule(
        label="sub_sq",
        statement="∀ {R : Type u_1} [_inst_1 : comm_ring R] (a b : R), (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2",
        left=(A - B) ** 2,
        right=A ** 2 - (INode(2) * A) * B + B ** 2,
    ),
    lean_rule(
        label="sub_pow_two",
        statement="∀ {R : Type u_1} [_inst_1 : comm_ring R] (a b : R), (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2",
        left=(A - B) ** 2,
        right=A ** 2 - (INode(2) * A) * B + B ** 2,
    ),
    lean_rule(
        label="sq_add_mul_sq_mul_sq_add_mul_sq",
        statement="∀ {R : Type u_1} [_inst_1 : comm_ring R] {x₁ x₂ y₁ y₂ n : R}, (x₁ ^ 2 + n * x₂ ^ 2) * (y₁ ^ 2 + n * y₂ ^ 2) = (x₁ * y₁ - n * x₂ * y₂) ^ 2 + n * (x₁ * y₂ + x₂ * y₁) ^ 2",
        # implicit_vars=[A, B, C, D, E],
        left=(A ** 2 + E * B ** 2) * (C ** 2 + E * D ** 2),
        right=(A * C - E * B * D) ** 2 + E * (A * D + B * C) ** 2,
    ),
    # lean_rule(
    #     label="pow_four_add_four_mul_pow_four",
    #     statement="∀ {R : Type u_1} [_inst_1 : comm_ring R] {a b : R}, a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)",
    #     implicit_vars=[A, B],
    #     left=A ^ 4 + 4 * B ^ 4,
    #     right=((A - B) ** 2 + B ** 2) * ((A + B) ** 2 + B ** 2),
    # ),
    lean_rule(
        label="add_neg_cancel_comm",
        statement="∀ {G : Type u_1} [_inst_1 : add_comm_group G] (a b : G), a + b + -a = b",
        left=A + B + -A,
        right=B,
    ),
    lean_rule(
        label="add_neg_cancel_comm_assoc",
        statement="∀ {G : Type u_1} [_inst_1 : add_comm_group G] (a b : G), a + (b + -a) = b",
        left=A + (B + -A),
        right=B,
    ),
    lean_rule(
        label="neg_add_cancel_comm_assoc",
        statement="∀ {G : Type u_1} [_inst_1 : add_comm_group G] (a b : G), -a + (b + a) = b",
        left=-A + (B + A),
        right=B,
    ),
    lean_rule(
        label="pow_two",
        statement="∀ {M : Type u} [_inst_1 : monoid M] (a : M), a ^ 2 = a * a",
        left=A ** 2,
        right=A * A,
    ),
    lean_rule(
        label="sq_sub_sq",
        statement="∀ {R : Type u_1} [_inst_1 : comm_ring R] (a b : R), a ^ 2 - b ^ 2 = (a + b) * (a - b)",
        left=A ** 2 - B ** 2,
        right=(A + B) * (A - B),
    ),
    lean_rule(
        label="add_sq",
        statement="∀ {R : Type u₁} [_inst_1 : comm_semiring R] (a b : R), (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2",
        left=(A + B) ** 2,
        right=A ** 2 + (INode(2) * A) * B + B ** 2,
    ),
    lean_rule(
        label="pow_two_nonneg",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] (a : R), 0 ≤ a ^ 2",
        node=ZERO <= A ** 2,
    ),
    lean_rule(
        label="pow_two_pos_of_ne_zero",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] (a : R), a ≠ 0 → 0 < a ^ 2",
        node=ZERO < A ** 2,
        hyps=[A != ZERO],
    ),
    lean_rule(
        label="abs_sq",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] (x : R), abs (x ^ 2) = x ^ 2",
        left=abs(A ** 2),
        right=A ** 2,
    ),
    lean_rule(
        label="sq_lt_sq'",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] {x y : R}, -y < x → x < y → x ^ 2 < y ^ 2",
        # implicit_vars=[A, B],
        node=A ** 2 < B ** 2,
        hyps=[-B < A, A < B],
    ),
    lean_rule(
        label="sq_le_sq'",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] {x y : R}, -y ≤ x → x ≤ y → x ^ 2 ≤ y ^ 2",
        # implicit_vars=[A, B],
        node=A ** 2 <= B ** 2,
        hyps=[-B <= A, A <= B],
    ),
    lean_rule(
        label="abs_le_of_sq_le_sq",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_ring R] {x y : R}, x ^ 2 ≤ y ^ 2 → 0 ≤ y → abs x ≤ y",
        # implicit_vars=[A, B],
        node=abs(A) <= B,
        hyps=[A ** 2 <= B ** 2, ZERO <= B],
    ),
    lean_rule(
        label="two_mul_le_add_pow_two",
        statement="∀ {R : Type u_2} [_inst_1 : linear_ordered_comm_ring R] (a b : R), 2 * a * b ≤ a ^ 2 + b ^ 2",
        node=(INode(2) * A) * B <= A ** 2 + B ** 2,
    ),
    lean_rule(
        label="neg_pow_two",
        statement="∀ {α : Type u_1} [_inst_1 : ring α] (z : α), (-z) ^ 2 = z ^ 2",
        left=(-A) ** 2,
        right=A ** 2,
    ),
    lean_rule(
        label="sq_add_sq_mul_sq_add_sq",
        statement="∀ {R : Type u_1} [_inst_1 : comm_ring R] {x₁ x₂ y₁ y₂ : R}, (x₁ ^ 2 + x₂ ^ 2) * (y₁ ^ 2 + y₂ ^ 2) = (x₁ * y₁ - x₂ * y₂) ^ 2 + (x₁ * y₂ + x₂ * y₁) ^ 2",
        # implicit_vars=[A, B, C, D],
        left=(A ** 2 + B ** 2) * (C ** 2 + D ** 2),
        right=(A * C - B * D) ** 2 + (A * D + B * C) ** 2,
    ),
    # lean_rule(
    #     label="pow_four_add_four_mul_pow_four'",
    #     statement="∀ {R : Type u_1} [_inst_1 : comm_ring R] {a b : R}, a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)",
    #     implicit_vars=[A, B],
    #     left=A ^ 4 + 4 * B ^ 4,
    #     right=(A ** 2 - (INode(2) * A) * B + INode(2) * B ** 2)
    #     * (A ** 2 + (INode(2) * A) * B + INode(2) * B ** 2),
    # ),
    lean_rule(
        label="sum_four_sq_mul_sum_four_sq",
        statement="∀ {R : Type u_1} [_inst_1 : comm_ring R] {x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : R}, (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2) * (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2) = (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄) ^ 2 + (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃) ^ 2 + (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂) ^ 2 + (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁) ^ 2",
        # implicit_vars=[A, B, C, D, E, F, G, H],
        left=(A ** 2 + B ** 2 + C ** 2 + D ** 2) * (E ** 2 + F ** 2 + G ** 2 + H ** 2),
        right=(A * E - B * F - C * G - D * H) ** 2
        + (A * F + B * E + C * H - D * G) ** 2
        + (A * G - B * H + C * E + D * F) ** 2
        + (A * H + B * G - C * F + D * E) ** 2,
    ),
    # lean_rule(
    #     label="sum_eight_sq_mul_sum_eight_sq",
    #     statement="∀ {R : Type u_1} [_inst_1 : comm_ring R] {x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ : R}, (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 + x₅ ^ 2 + x₆ ^ 2 + x₇ ^ 2 + x₈ ^ 2) * (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 + y₅ ^ 2 + y₆ ^ 2 + y₇ ^ 2 + y₈ ^ 2) = (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄ - x₅ * y₅ - x₆ * y₆ - x₇ * y₇ - x₈ * y₈) ^ 2 + (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃ + x₅ * y₆ - x₆ * y₅ - x₇ * y₈ + x₈ * y₇) ^ 2 + (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂ + x₅ * y₇ + x₆ * y₈ - x₇ * y₅ - x₈ * y₆) ^ 2 + (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁ + x₅ * y₈ - x₆ * y₇ + x₇ * y₆ - x₈ * y₅) ^ 2 + (x₁ * y₅ - x₂ * y₆ - x₃ * y₇ - x₄ * y₈ + x₅ * y₁ + x₆ * y₂ + x₇ * y₃ + x₈ * y₄) ^ 2 + (x₁ * y₆ + x₂ * y₅ - x₃ * y₈ + x₄ * y₇ - x₅ * y₂ + x₆ * y₁ - x₇ * y₄ + x₈ * y₃) ^ 2 + (x₁ * y₇ + x₂ * y₈ + x₃ * y₅ - x₄ * y₆ - x₅ * y₃ + x₆ * y₄ + x₇ * y₁ - x₈ * y₂) ^ 2 + (x₁ * y₈ - x₂ * y₇ + x₃ * y₆ + x₄ * y₅ - x₅ * y₄ - x₆ * y₃ + x₇ * y₂ + x₈ * y₁) ^ 2",
    #     implicit_vars=[A, B, C, D, E, F, G, H, I, J, K, L, M, N, M, O],
    #     left=(A ** 2 + B ** 2 + C ** 2 + D ** 2 + E ** 2 + F ** 2 + G ** 2 + H ** 2)
    #     * (I ** 2 + J ** 2 + K ** 2 + L ** 2 + M ** 2 + N ** 2 + M ** 2 + O ** 2),
    #     right=(A * I - B * J - C * K - D * L - E * M - F * N - G * M - H * O) ** 2
    #     + (A * J + B * I + C * L - D * K + E * N - F * M - G * O + H * M) ** 2
    #     + (A * K - B * L + C * I + D * J + E * M + F * O - G * M - H * N) ** 2
    #     + (A * L + B * K - C * J + D * I + E * O - F * M + G * N - H * M) ** 2
    #     + (A * M - B * N - C * M - D * O + E * I + F * J + G * K + H * L) ** 2
    #     + (A * N + B * M - C * O + D * M - E * J + F * I - G * L + H * K) ** 2
    #     + (A * M + B * O + C * M - D * N - E * K + F * L + G * I - H * J) ** 2
    #     + (A * O - B * M + C * N + D * M - E * L - F * K + G * J + H * I) ** 2,
    # ),
    # lean_rule(
    #     label="pow_one",
    #     statement="∀ {M : Type u} [_inst_1 : monoid M] (a : M), a ^ 1 = a",
    #     left=A ^ ONE,
    #     right=A,
    # ),
    # lean_rule(
    #     label="one_pow",
    #     statement="∀ {M : Type u} [_inst_1 : monoid M] (n : ℕ), 1 ^ n = 1",
    #     left=ONE ^ A,
    #     right=ONE,
    # ),
]
LEAN_ORDER_RULES = [
    lean_rule(
        label="has_lt.lt.ne",
        statement="∀ {α : Type u} [_inst_1 : preorder α] {a b : α}, a < b → a ≠ b",
        # implicit_vars=[A, B],
        node=A != B,
        hyps=[A < B],
    ),
    lean_rule(
        label="le_rfl",
        statement="∀ {α : Type u} [_inst_1 : preorder α] {x : α}, x ≤ x",
        # implicit_vars=[A],
        node=A <= A,
    ),
    lean_rule(
        label="eq.ge",
        statement="∀ {α : Type u} [_inst_1 : preorder α] {x y : α}, x = y → y ≤ x",
        # implicit_vars=[A, B],
        node=B <= A,
        hyps=[A == B],
    ),
    lean_rule(
        label="eq.trans_le",
        statement="∀ {α : Type u} [_inst_1 : preorder α] {x y z : α}, x = y → y ≤ z → x ≤ z",
        # implicit_vars=[A, B, C],
        node=A <= C,
        hyps=[A == B, B <= C],
    ),
    # lean_rule(
    #     label="has_le.le.ge",
    #     statement="∀ {α : Type u} [_inst_1 : has_le α] {x y : α}, x ≤ y → y ≥ x",
    #     implicit_vars=[A, B],
    #     node=B >= A,
    #     hyps=[A <= B],
    # ),
    lean_rule(
        label="has_le.le.trans_eq",
        statement="∀ {α : Type u} [_inst_1 : preorder α] {x y z : α}, x ≤ y → y = z → x ≤ z",
        # implicit_vars=[A, B, C],
        node=A <= C,
        hyps=[A <= B, B == C],
    ),
    lean_rule(
        label="has_le.le.lt_iff_ne",
        statement="∀ {α : Type u} [_inst_1 : partial_order α] {x y : α}, x ≤ y → (x < y ↔ x ≠ y)",
        # implicit_vars=[A, B],
        left=A < B,
        right=A != B,
        hyps=[A <= B],
    ),
    lean_rule(
        label="has_le.le.le_iff_eq",
        statement="∀ {α : Type u} [_inst_1 : partial_order α] {x y : α}, x ≤ y → (y ≤ x ↔ y = x)",
        # implicit_vars=[A, B],
        left=B <= A,
        right=B == A,
        hyps=[A <= B],
    ),
    # lean_rule(
    #     label="has_lt.lt.gt",
    #     statement="∀ {α : Type u} [_inst_1 : has_lt α] {x y : α}, x < y → y > x",
    #     implicit_vars=[A, B],
    #     node=B > A,
    #     hyps=[A < B],
    # ),
    lean_rule(
        label="has_lt.lt.ne'",
        statement="∀ {α : Type u} [_inst_1 : preorder α] {x y : α}, x < y → y ≠ x",
        # implicit_vars=[A, B],
        node=B != A,
        hyps=[A < B],
    ),
    # lean_rule(
    #     label="ge.le",
    #     statement="∀ {α : Type u} [_inst_1 : has_le α] {x y : α}, x ≥ y → y ≤ x",
    #     implicit_vars=[A, B],
    #     node=B <= A,
    #     hyps=[A >= B],
    # ),
    # lean_rule(
    #     label="gt.lt",
    #     statement="∀ {α : Type u} [_inst_1 : has_lt α] {x y : α}, x > y → y < x",
    #     implicit_vars=[A, B],
    #     node=B < A,
    #     hyps=[A > B],
    # ),
    lean_rule(
        label="ge_of_eq",
        statement="∀ {α : Type u} [_inst_1 : preorder α] {a b : α}, a = b → a ≥ b",
        # implicit_vars=[A, B],
        node=A >= B,
        hyps=[A == B],
    ),
    # lean_rule(
    #     label="ge_iff_le",
    #     statement="∀ {α : Type u} [_inst_1 : preorder α] {a b : α}, a ≥ b ↔ b ≤ a",
    #     implicit_vars=[A, B],
    #     left=A >= B,
    #     right=B <= A,
    # ),
    # lean_rule(
    #     label="gt_iff_lt",
    #     statement="∀ {α : Type u} [_inst_1 : preorder α] {a b : α}, a > b ↔ b < a",
    #     implicit_vars=[A, B],
    #     left=A > B,
    #     right=B < A,
    # ),
    lean_rule(
        label="ne.le_iff_lt",
        statement="∀ {α : Type u} [_inst_1 : partial_order α] {a b : α}, a ≠ b → (a ≤ b ↔ a < b)",
        # implicit_vars=[A, B],
        left=A <= B,
        right=A < B,
        hyps=[A != B],
    ),
    # lean_rule(
    #     label="eq_of_forall_le_iff",
    #     statement="∀ {α : Type u} [_inst_1 : partial_order α] {a b : α}, (∀ (c : α), c ≤ a ↔ c ≤ b) → a = b",
    #     implicit_vars=[A, B],
    #     left=A,
    #     right=B,
    # ),
    # lean_rule(
    #     label="le_of_forall_le",
    #     statement="∀ {α : Type u} [_inst_1 : preorder α] {a b : α}, (∀ (c : α), c ≤ a → c ≤ b) → a ≤ b",
    #     implicit_vars=[E, F],
    #     node=E <= F,
    # ),
    # lean_rule(
    #     label="le_of_forall_le'",
    #     statement="∀ {α : Type u} [_inst_1 : preorder α] {a b : α}, (∀ (c : α), a ≤ c → b ≤ c) → b ≤ a",
    #     implicit_vars=[E, F],
    #     node=F <= E,
    # ),
    # lean_rule(
    #     label="le_of_forall_lt",
    #     statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b : α}, (∀ (c : α), c < a → c < b) → a ≤ b",
    #     implicit_vars=[E, F],
    #     node=E <= F,
    # ),
    # lean_rule(
    #     label="le_of_forall_lt'",
    #     statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b : α}, (∀ (c : α), a < c → b < c) → b ≤ a",
    #     implicit_vars=[E, F],
    #     node=F <= E,
    # ),
    # lean_rule(
    #     label="eq_of_forall_ge_iff",
    #     statement="∀ {α : Type u} [_inst_1 : partial_order α] {a b : α}, (∀ (c : α), a ≤ c ↔ b ≤ c) → a = b",
    #     implicit_vars=[E, F],
    #     left=E,
    #     right=F,
    # ),
]

LEAN_ORDER_FUNCTIONS_RULES = [
    lean_rule(
        label="lt_max_of_lt_left",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, a < b → a < max b c",
        # implicit_vars=[A, B, C],
        node=A < Max(B, C),
        hyps=[A < B],
    ),
    lean_rule(
        label="lt_max_of_lt_right",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, a < c → a < max b c",
        # implicit_vars=[A, B, C],
        node=A < Max(B, C),
        hyps=[A < C],
    ),
    lean_rule(
        label="min_lt_of_left_lt",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, a < c → min a b < c",
        # implicit_vars=[A, B, C],
        node=Min(A, B) < C,
        hyps=[A < C],
    ),
    lean_rule(
        label="min_lt_of_right_lt",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, b < c → min a b < c",
        # implicit_vars=[A, B, C],
        node=Min(A, B) < C,
        hyps=[B < C],
    ),
    lean_rule(
        label="max_min_distrib_left",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, max a (min b c) = min (max a b) (max a c)",
        # implicit_vars=[A, B, C],
        left=Max(A, (Min(B, C))),
        right=Min((Max(A, B)), (Max(A, C))),
    ),
    lean_rule(
        label="max_min_distrib_right",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, max (min a b) c = min (max a c) (max b c)",
        # implicit_vars=[A, B, C],
        left=Max((Min(A, B)), C),
        right=Min((Max(A, C)), (Max(B, C))),
    ),
    lean_rule(
        label="min_max_distrib_left",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, min a (max b c) = max (min a b) (min a c)",
        # implicit_vars=[A, B, C],
        left=Min(A, (Max(B, C))),
        right=Max((Min(A, B)), (Min(A, C))),
    ),
    lean_rule(
        label="min_max_distrib_right",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, min (max a b) c = max (min a c) (min b c)",
        # implicit_vars=[A, B, C],
        left=Min((Max(A, B)), C),
        right=Max((Min(A, C)), Min(B, C)),
    ),
    lean_rule(
        label="min_le_max",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b : α}, min a b ≤ max a b",
        # implicit_vars=[A, B],
        node=Min(A, B) <= Max(A, B),
    ),
    lean_rule(
        label="min_eq_left_iff",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b : α}, min a b = a ↔ a ≤ b",
        # implicit_vars=[A, B],
        left=Min(A, B) == A,
        right=A <= B,
    ),
    lean_rule(
        label="min_eq_right_iff",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b : α}, min a b = b ↔ b ≤ a",
        # implicit_vars=[A, B],
        left=Min(A, B) == B,
        right=B <= A,
    ),
    lean_rule(
        label="max_eq_left_iff",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b : α}, max a b = a ↔ b ≤ a",
        # implicit_vars=[A, B],
        left=Max(A, B) == A,
        right=B <= A,
    ),
    lean_rule(
        label="max_eq_right_iff",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b : α}, max a b = b ↔ a ≤ b",
        # implicit_vars=[A, B],
        left=Max(A, B) == B,
        right=A <= B,
    ),
    lean_rule(
        label="max_lt_max",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c d : α}, a < c → b < d → max a b < max c d",
        # implicit_vars=[A, B, C, D],
        node=Max(A, B) < Max(C, D),
        hyps=[A < C, B < D],
    ),
    lean_rule(
        label="min_lt_min",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c d : α}, a < c → b < d → min a b < min c d",
        # implicit_vars=[A, B, C, D],
        node=Min(A, B) < Min(C, D),
        hyps=[A < C, B < D],
    ),
    lean_rule(
        label="min_right_comm",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] (a b c : α), min (min a b) c = min (min a c) b",
        left=Min((Min(A, B)), C),
        right=Min((Min(A, C)), B),
    ),
    lean_rule(
        label="max.left_comm",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] (a b c : α), max a (max b c) = max b (max a c)",
        left=Max(A, (Max(B, C))),
        right=Max(B, (Max(A, C))),
    ),
    lean_rule(
        label="max.right_comm",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] (a b c : α), max (max a b) c = max (max a c) b",
        left=Max((Max(A, B)), C),
        right=Max((Max(A, C)), B),
    ),
    lean_rule(
        label="le_of_max_le_left",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, max a b ≤ c → a ≤ c",
        # implicit_vars=[A, B, C],
        node=A <= C,
        hyps=[Max(A, B) <= C],
    ),
    lean_rule(
        label="le_of_max_le_right",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, max a b ≤ c → b ≤ c",
        # implicit_vars=[A, B, C],
        node=B <= C,
        hyps=[Max(A, B) <= C],
    ),
    lean_rule(
        label="max_le_max",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c d : α}, a ≤ c → b ≤ d → max a b ≤ max c d",
        # implicit_vars=[A, B, C, D],
        node=Max(A, B) <= Max(C, D),
        hyps=[A <= C, B <= D],
    ),
    lean_rule(
        label="min_le_min",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c d : α}, a ≤ c → b ≤ d → min a b ≤ min c d",
        # implicit_vars=[A, B, C, D],
        node=Min(A, B) <= Min(C, D),
        hyps=[A <= C, B <= D],
    ),
    lean_rule(
        label="le_max_of_le_left",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, a ≤ b → a ≤ max b c",
        # implicit_vars=[A, B, C],
        node=A <= Max(B, C),
        hyps=[A <= B],
    ),
    lean_rule(
        label="le_max_of_le_right",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, a ≤ c → a ≤ max b c",
        # implicit_vars=[A, B, C],
        node=A <= Max(B, C),
        hyps=[A <= C],
    ),
    lean_rule(
        label="min_le_of_left_le",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, a ≤ c → min a b ≤ c",
        # implicit_vars=[A, B, C],
        node=Min(A, B) <= C,
        hyps=[A <= C],
    ),
    lean_rule(
        label="min_le_of_right_le",
        statement="∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, b ≤ c → min a b ≤ c",
        # implicit_vars=[A, B, C],
        node=Min(A, B) <= C,
        hyps=[B <= C],
    ),
]

LEAN_ORDERED_GROUP_RULES = [
    lean_rule(
        label="neg_le_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a ≤ b → -b ≤ -a",
        # implicit_vars=[A, B],
        node=-B <= -A,
        hyps=[A <= B],
    ),
    lean_rule(
        label="le_of_neg_le_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, -b ≤ -a → a ≤ b",
        # implicit_vars=[A, B],
        node=A <= B,
        hyps=[-B <= -A],
    ),
    lean_rule(
        label="nonneg_of_neg_nonpos",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, -a ≤ 0 → 0 ≤ a",
        # implicit_vars=[A],
        node=ZERO <= A,
        hyps=[-A <= ZERO],
    ),
    lean_rule(
        label="neg_nonpos_of_nonneg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, 0 ≤ a → -a ≤ 0",
        # implicit_vars=[A],
        node=-A <= ZERO,
        hyps=[ZERO <= A],
    ),
    lean_rule(
        label="nonpos_of_neg_nonneg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, 0 ≤ -a → a ≤ 0",
        # implicit_vars=[A],
        node=A <= ZERO,
        hyps=[ZERO <= -A],
    ),
    lean_rule(
        label="neg_nonneg_of_nonpos",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, a ≤ 0 → 0 ≤ -a",
        # implicit_vars=[A],
        node=ZERO <= -A,
        hyps=[A <= ZERO],
    ),
    lean_rule(
        label="neg_lt_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a < b → -b < -a",
        # implicit_vars=[A, B],
        node=-B < -A,
        hyps=[A < B],
    ),
    lean_rule(
        label="lt_of_neg_lt_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, -b < -a → a < b",
        # implicit_vars=[A, B],
        node=A < B,
        hyps=[-B < -A],
    ),
    lean_rule(
        label="pos_of_neg_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, -a < 0 → 0 < a",
        # implicit_vars=[A],
        node=ZERO < A,
        hyps=[-A < ZERO],
    ),
    lean_rule(
        label="neg_neg_of_pos",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, 0 < a → -a < 0",
        # implicit_vars=[A],
        node=-A < ZERO,
        hyps=[ZERO < A],
    ),
    lean_rule(
        label="neg_of_neg_pos",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, 0 < -a → a < 0",
        # implicit_vars=[A],
        node=A < ZERO,
        hyps=[ZERO < -A],
    ),
    lean_rule(
        label="neg_pos_of_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, a < 0 → 0 < -a",
        # implicit_vars=[A],
        node=ZERO < -A,
        hyps=[A < ZERO],
    ),
    lean_rule(
        label="le_neg_of_le_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a ≤ -b → b ≤ -a",
        # implicit_vars=[A, B],
        node=B <= -A,
        hyps=[A <= -B],
    ),
    lean_rule(
        label="neg_le_of_neg_le",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, -a ≤ b → -b ≤ a",
        # implicit_vars=[A, B],
        node=-B <= A,
        hyps=[-A <= B],
    ),
    lean_rule(
        label="lt_neg_of_lt_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a < -b → b < -a",
        # implicit_vars=[A, B],
        node=B < -A,
        hyps=[A < -B],
    ),
    lean_rule(
        label="neg_lt_of_neg_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, -a < b → -b < a",
        # implicit_vars=[A, B],
        node=-B < A,
        hyps=[-A < B],
    ),
    lean_rule(
        label="add_le_of_le_neg_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, b ≤ -a + c → a + b ≤ c",
        # implicit_vars=[A, B, C],
        node=A + B <= C,
        hyps=[B <= -A + C],
    ),
    lean_rule(
        label="le_neg_add_of_add_le",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a + b ≤ c → b ≤ -a + c",
        # implicit_vars=[A, B, C],
        node=B <= -A + C,
        hyps=[A + B <= C],
    ),
    lean_rule(
        label="le_add_of_neg_add_le",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -b + a ≤ c → a ≤ b + c",
        # implicit_vars=[A, B, C],
        node=A <= B + C,
        hyps=[-B + A <= C],
    ),
    lean_rule(
        label="neg_add_le_of_le_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a ≤ b + c → -b + a ≤ c",
        # implicit_vars=[A, B, C],
        node=-B + A <= C,
        hyps=[A <= B + C],
    ),
    lean_rule(
        label="le_add_of_neg_add_le_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -b + a ≤ c → a ≤ b + c",
        # implicit_vars=[A, B, C],
        node=A <= B + C,
        hyps=[-B + A <= C],
    ),
    lean_rule(
        label="neg_add_le_left_of_le_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a ≤ b + c → -b + a ≤ c",
        # implicit_vars=[A, B, C],
        node=-B + A <= C,
        hyps=[A <= B + C],
    ),
    lean_rule(
        label="le_add_of_neg_add_le_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -c + a ≤ b → a ≤ b + c",
        # implicit_vars=[A, B, C],
        node=A <= B + C,
        hyps=[-C + A <= B],
    ),
    lean_rule(
        label="neg_add_le_right_of_le_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a ≤ b + c → -c + a ≤ b",
        # implicit_vars=[A, B, C],
        node=-C + A <= B,
        hyps=[A <= B + C],
    ),
    lean_rule(
        label="add_lt_of_lt_neg_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, b < -a + c → a + b < c",
        # implicit_vars=[A, B, C],
        node=A + B < C,
        hyps=[B < -A + C],
    ),
    lean_rule(
        label="lt_neg_add_of_add_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a + b < c → b < -a + c",
        # implicit_vars=[A, B, C],
        node=B < -A + C,
        hyps=[A + B < C],
    ),
    lean_rule(
        label="lt_add_of_neg_add_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -b + a < c → a < b + c",
        # implicit_vars=[A, B, C],
        node=A < B + C,
        hyps=[-B + A < C],
    ),
    lean_rule(
        label="neg_add_lt_of_lt_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a < b + c → -b + a < c",
        # implicit_vars=[A, B, C],
        node=-B + A < C,
        hyps=[A < B + C],
    ),
    lean_rule(
        label="lt_add_of_neg_add_lt_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -b + a < c → a < b + c",
        # implicit_vars=[A, B, C],
        node=A < B + C,
        hyps=[-B + A < C],
    ),
    lean_rule(
        label="neg_add_lt_left_of_lt_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a < b + c → -b + a < c",
        # implicit_vars=[A, B, C],
        node=-B + A < C,
        hyps=[A < B + C],
    ),
    lean_rule(
        label="lt_add_of_neg_add_lt_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -c + a < b → a < b + c",
        # implicit_vars=[A, B, C],
        node=A < B + C,
        hyps=[-C + A < B],
    ),
    lean_rule(
        label="neg_add_lt_right_of_lt_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a < b + c → -c + a < b",
        # implicit_vars=[A, B, C],
        node=-C + A < B,
        hyps=[A < B + C],
    ),
    lean_rule(
        label="neg_neg_iff_pos",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, -a < 0 ↔ 0 < a",
        # implicit_vars=[A],
        left=-A < ZERO,
        right=ZERO < A,
    ),
    lean_rule(
        label="neg_le_neg_iff",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, -a ≤ -b ↔ b ≤ a",
        # implicit_vars=[A, B],
        left=-A <= -B,
        right=B <= A,
    ),
    lean_rule(
        label="neg_le",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, -a ≤ b ↔ -b ≤ a",
        # implicit_vars=[A, B],
        left=-A <= B,
        right=-B <= A,
    ),
    lean_rule(
        label="le_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a ≤ -b ↔ b ≤ -a",
        # implicit_vars=[A, B],
        left=A <= -B,
        right=B <= -A,
    ),
    lean_rule(
        label="neg_le_iff_add_nonneg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, -a ≤ b ↔ 0 ≤ b + a",
        # implicit_vars=[A, B],
        left=-A <= B,
        right=ZERO <= B + A,
    ),
    lean_rule(
        label="neg_le_iff_add_nonneg'",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, -a ≤ b ↔ 0 ≤ a + b",
        # implicit_vars=[A, B],
        left=-A <= B,
        right=ZERO <= A + B,
    ),
    lean_rule(
        label="neg_lt_iff_pos_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, -a < b ↔ 0 < b + a",
        # implicit_vars=[A, B],
        left=-A < B,
        right=ZERO < B + A,
    ),
    lean_rule(
        label="neg_lt_iff_pos_add'",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, -a < b ↔ 0 < a + b",
        # implicit_vars=[A, B],
        left=-A < B,
        right=ZERO < A + B,
    ),
    lean_rule(
        label="le_neg_iff_add_nonpos",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a ≤ -b ↔ a + b ≤ 0",
        # implicit_vars=[A, B],
        left=A <= -B,
        right=A + B <= ZERO,
    ),
    lean_rule(
        label="le_neg_iff_add_nonpos'",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a ≤ -b ↔ b + a ≤ 0",
        # implicit_vars=[A, B],
        left=A <= -B,
        right=B + A <= ZERO,
    ),
    lean_rule(
        label="lt_neg_iff_add_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a < -b ↔ a + b < 0",
        # implicit_vars=[A, B],
        left=A < -B,
        right=A + B < ZERO,
    ),
    lean_rule(
        label="lt_neg_iff_add_neg'",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a < -b ↔ b + a < 0",
        # implicit_vars=[A, B],
        left=A < -B,
        right=B + A < ZERO,
    ),
    lean_rule(
        label="neg_nonpos",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, -a ≤ 0 ↔ 0 ≤ a",
        # implicit_vars=[A],
        left=-A <= ZERO,
        right=ZERO <= A,
    ),
    lean_rule(
        label="neg_nonneg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, 0 ≤ -a ↔ a ≤ 0",
        # implicit_vars=[A],
        left=ZERO <= -A,
        right=A <= ZERO,
    ),
    lean_rule(
        label="neg_le_self",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, 0 ≤ a → -a ≤ a",
        # implicit_vars=[A],
        node=-A <= A,
        hyps=[ZERO <= A],
    ),
    lean_rule(
        label="self_le_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, a ≤ 0 → a ≤ -a",
        # implicit_vars=[A],
        node=A <= -A,
        hyps=[A <= ZERO],
    ),
    lean_rule(
        label="neg_lt_neg_iff",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, -a < -b ↔ b < a",
        # implicit_vars=[A, B],
        left=-A < -B,
        right=B < A,
    ),
    lean_rule(
        label="neg_lt_zero",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, -a < 0 ↔ 0 < a",
        # implicit_vars=[A],
        left=-A < ZERO,
        right=ZERO < A,
    ),
    lean_rule(
        label="neg_pos",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, 0 < -a ↔ a < 0",
        # implicit_vars=[A],
        left=ZERO < -A,
        right=A < ZERO,
    ),
    lean_rule(
        label="neg_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, -a < b ↔ -b < a",
        # implicit_vars=[A, B],
        left=-A < B,
        right=-B < A,
    ),
    lean_rule(
        label="lt_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a < -b ↔ b < -a",
        # implicit_vars=[A, B],
        left=A < -B,
        right=B < -A,
    ),
    lean_rule(
        label="neg_lt_self",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a : α}, 0 < a → -a < a",
        # implicit_vars=[A],
        node=-A < A,
        hyps=[ZERO < A],
    ),
    lean_rule(
        label="le_neg_add_iff_add_le",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, b ≤ -a + c ↔ a + b ≤ c",
        # implicit_vars=[A, B, C],
        left=B <= -A + C,
        right=A + B <= C,
    ),
    lean_rule(
        label="neg_add_le_iff_le_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -b + a ≤ c ↔ a ≤ b + c",
        # implicit_vars=[A, B, C],
        left=-B + A <= C,
        right=A <= B + C,
    ),
    lean_rule(
        label="add_neg_le_iff_le_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a + -c ≤ b ↔ a ≤ b + c",
        # implicit_vars=[A, B, C],
        left=A + -C <= B,
        right=A <= B + C,
    ),
    lean_rule(
        label="add_neg_le_iff_le_add'",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a + -b ≤ c ↔ a ≤ b + c",
        # implicit_vars=[A, B, C],
        left=A + -B <= C,
        right=A <= B + C,
    ),
    lean_rule(
        label="neg_add_le_iff_le_add'",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -c + a ≤ b ↔ a ≤ b + c",
        # implicit_vars=[A, B, C],
        left=-C + A <= B,
        right=A <= B + C,
    ),
    lean_rule(
        label="lt_neg_add_iff_add_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, b < -a + c ↔ a + b < c",
        # implicit_vars=[A, B, C],
        left=B < -A + C,
        right=A + B < C,
    ),
    lean_rule(
        label="neg_add_lt_iff_lt_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -b + a < c ↔ a < b + c",
        # implicit_vars=[A, B, C],
        left=-B + A < C,
        right=A < B + C,
    ),
    lean_rule(
        label="neg_add_lt_iff_lt_add_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -c + a < b ↔ a < b + c",
        # implicit_vars=[A, B, C],
        left=-C + A < B,
        right=A < B + C,
    ),
    lean_rule(
        label="add_neg_le_add_neg_iff",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c d : α}, a + -b ≤ c + -d ↔ a + d ≤ c + b",
        # implicit_vars=[A, B, C, D],
        left=A + -B <= C + -D,
        right=A + D <= C + B,
    ),
    lean_rule(
        label="sub_le_self_iff",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] (a : α) {b : α}, a - b ≤ a ↔ 0 ≤ b",
        # implicit_vars=[B],
        left=A - B <= A,
        right=ZERO <= B,
    ),
    lean_rule(
        label="sub_lt_self_iff",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] (a : α) {b : α}, a - b < a ↔ 0 < b",
        # implicit_vars=[B],
        left=A - B < A,
        right=ZERO < B,
    ),
    lean_rule(
        label="sub_le_sub",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c d : α}, a ≤ b → c ≤ d → a - d ≤ b - c",
        # implicit_vars=[A, B, C, D],
        node=A - D <= B - C,
        hyps=[A <= B, C <= D],
    ),
    lean_rule(
        label="sub_lt_sub",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c d : α}, a < b → c < d → a - d < b - c",
        # implicit_vars=[A, B, C, D],
        node=A - D < B - C,
        hyps=[A < B, C < D],
    ),
    lean_rule(
        label="sub_le_sub_iff",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c d : α}, a - b ≤ c - d ↔ a + d ≤ c + b",
        # implicit_vars=[A, B, C, D],
        left=A - B <= C - D,
        right=A + D <= C + B,
    ),
    lean_rule(
        label="sub_le_sub_iff_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] (a : α) {b c : α}, a - b ≤ a - c ↔ c ≤ b",
        # implicit_vars=[B, C],
        left=A - B <= A - C,
        right=C <= B,
    ),
    lean_rule(
        label="sub_le_sub_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a ≤ b → ∀ (c : α), c - b ≤ c - a",
        # implicit_vars=[A, B],
        node=C - B <= C - A,
        hyps=[A <= B],
        # hyp_first=True,
    ),
    lean_rule(
        label="sub_le_sub_iff_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α} (c : α), a - c ≤ b - c ↔ a ≤ b",
        # implicit_vars=[A, B],
        left=A - C <= B - C,
        right=A <= B,
    ),
    lean_rule(
        label="sub_le_sub_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a ≤ b → ∀ (c : α), a - c ≤ b - c",
        # implicit_vars=[A, B],
        node=A - C <= B - C,
        hyps=[A <= B],
        # hyp_first=True,
    ),
    lean_rule(
        label="sub_lt_sub_iff_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] (a : α) {b c : α}, a - b < a - c ↔ c < b",
        # implicit_vars=[B, C],
        left=A - B < A - C,
        right=C < B,
    ),
    lean_rule(
        label="sub_lt_sub_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a < b → ∀ (c : α), c - b < c - a",
        # implicit_vars=[A, B],
        node=C - B < C - A,
        hyps=[A < B],
        # hyp_first=True,
    ),
    lean_rule(
        label="sub_lt_sub_iff_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α} (c : α), a - c < b - c ↔ a < b",
        # implicit_vars=[A, B],
        left=A - C < B - C,
        right=A < B,
    ),
    lean_rule(
        label="sub_lt_sub_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a < b → ∀ (c : α), a - c < b - c",
        # implicit_vars=[A, B],
        node=A - C < B - C,
        hyps=[A < B],
        # hyp_first=True,
    ),
    lean_rule(
        label="sub_nonneg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, 0 ≤ a - b ↔ b ≤ a",
        # implicit_vars=[A, B],
        left=ZERO <= A - B,
        right=B <= A,
    ),
    lean_rule(
        label="sub_nonpos",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a - b ≤ 0 ↔ a ≤ b",
        # implicit_vars=[A, B],
        left=A - B <= ZERO,
        right=A <= B,
    ),
    lean_rule(
        label="sub_pos",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, 0 < a - b ↔ b < a",
        # implicit_vars=[A, B],
        left=ZERO < A - B,
        right=B < A,
    ),
    lean_rule(
        label="sub_lt_zero",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a - b < 0 ↔ a < b",
        # implicit_vars=[A, B],
        left=A - B < ZERO,
        right=A < B,
    ),
    lean_rule(
        label="le_sub_iff_add_le'",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, b ≤ c - a ↔ a + b ≤ c",
        # implicit_vars=[A, B, C],
        left=B <= C - A,
        right=A + B <= C,
    ),
    lean_rule(
        label="le_sub_iff_add_le",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a ≤ c - b ↔ a + b ≤ c",
        # implicit_vars=[A, B, C],
        left=A <= C - B,
        right=A + B <= C,
    ),
    lean_rule(
        label="sub_le_iff_le_add'",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a - b ≤ c ↔ a ≤ b + c",
        # implicit_vars=[A, B, C],
        left=A - B <= C,
        right=A <= B + C,
    ),
    lean_rule(
        label="sub_le_iff_le_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a - c ≤ b ↔ a ≤ b + c",
        # implicit_vars=[A, B, C],
        left=A - C <= B,
        right=A <= B + C,
    ),
    lean_rule(
        label="neg_le_sub_iff_le_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -b ≤ a - c ↔ c ≤ a + b",
        # implicit_vars=[A, B, C],
        left=-B <= A - C,
        right=C <= A + B,
    ),
    lean_rule(
        label="neg_le_sub_iff_le_add'",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -a ≤ b - c ↔ c ≤ a + b",
        # implicit_vars=[A, B, C],
        left=-A <= B - C,
        right=C <= A + B,
    ),
    lean_rule(
        label="sub_le",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a - b ≤ c ↔ a - c ≤ b",
        # implicit_vars=[A, B, C],
        left=A - B <= C,
        right=A - C <= B,
    ),
    lean_rule(
        label="le_sub",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a ≤ b - c ↔ c ≤ b - a",
        # implicit_vars=[A, B, C],
        left=A <= B - C,
        right=C <= B - A,
    ),
    lean_rule(
        label="lt_sub_iff_add_lt'",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, b < c - a ↔ a + b < c",
        # implicit_vars=[A, B, C],
        left=B < C - A,
        right=A + B < C,
    ),
    lean_rule(
        label="lt_sub_iff_add_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a < c - b ↔ a + b < c",
        # implicit_vars=[A, B, C],
        left=A < C - B,
        right=A + B < C,
    ),
    lean_rule(
        label="sub_lt_iff_lt_add'",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a - b < c ↔ a < b + c",
        # implicit_vars=[A, B, C],
        left=A - B < C,
        right=A < B + C,
    ),
    lean_rule(
        label="sub_lt_iff_lt_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a - c < b ↔ a < b + c",
        # implicit_vars=[A, B, C],
        left=A - C < B,
        right=A < B + C,
    ),
    lean_rule(
        label="neg_lt_sub_iff_lt_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -b < a - c ↔ c < a + b",
        # implicit_vars=[A, B, C],
        left=-B < A - C,
        right=C < A + B,
    ),
    lean_rule(
        label="neg_lt_sub_iff_lt_add'",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, -a < b - c ↔ c < a + b",
        # implicit_vars=[A, B, C],
        left=-A < B - C,
        right=C < A + B,
    ),
    lean_rule(
        label="sub_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a - b < c ↔ a - c < b",
        # implicit_vars=[A, B, C],
        left=A - B < C,
        right=A - C < B,
    ),
    lean_rule(
        label="lt_sub",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a < b - c ↔ c < b - a",
        # implicit_vars=[A, B, C],
        left=A < B - C,
        right=C < B - A,
    ),
    # lean_rule(
    #     label="linear_ordered_add_comm_group.add_lt_add_left",
    #     statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b : α), a < b → ∀ (c : α), c + a < c + b",
    #     node=C + A < C + B,
    #     hyps=[A < B],
    # ),
    lean_rule(
        label="min_neg_neg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b : α), min (-a) (-b) = -max a b",
        left=Min((-A), (-B)),
        right=-Max(A, B),
    ),
    lean_rule(
        label="max_neg_neg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b : α), max (-a) (-b) = -min a b",
        left=Max((-A), (-B)),
        right=-Min(A, B),
    ),
    lean_rule(
        label="min_sub_sub_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b c : α), min (a - c) (b - c) = min a b - c",
        left=Min((A - C), (B - C)),
        right=Min(A, B) - C,
    ),
    lean_rule(
        label="max_sub_sub_right",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b c : α), max (a - c) (b - c) = max a b - c",
        left=Max((A - C), (B - C)),
        right=Max(A, B) - C,
    ),
    lean_rule(
        label="min_sub_sub_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b c : α), min (a - b) (a - c) = a - max b c",
        left=Min((A - B), (A - C)),
        right=A - Max(B, C),
    ),
    lean_rule(
        label="max_sub_sub_left",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b c : α), max (a - b) (a - c) = a - min b c",
        left=Max((A - B), (A - C)),
        right=A - Min(B, C),
    ),
    lean_rule(
        label="max_zero_sub_eq_self",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a : α), max a 0 - max (-a) 0 = a",
        left=Max(A, ZERO) - Max((-A), ZERO),
        right=A,
    ),
    lean_rule(
        label="eq_zero_of_neg_eq",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a : α}, -a = a → a = 0",
        # implicit_vars=[A],
        left=A,
        right=ZERO,
        hyps=[-A == A],
    ),
    lean_rule(
        label="sub_le_sub_flip",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b : α}, a - b ≤ b - a ↔ a ≤ b",
        # implicit_vars=[A, B],
        left=A - B <= B - A,
        right=A <= B,
    ),
    lean_rule(
        label="max_zero_sub_max_neg_zero_eq_self",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a : α), max a 0 - max (-a) 0 = a",
        left=Max(A, ZERO) - Max((-A), ZERO),
        right=A,
    ),
    lean_rule(
        label="abs_of_nonneg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a : α}, 0 ≤ a → abs a = a",
        # implicit_vars=[A],
        left=abs(A),
        right=A,
        hyps=[ZERO <= A],
    ),
    lean_rule(
        label="abs_of_pos",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a : α}, 0 < a → abs a = a",
        # implicit_vars=[A],
        left=abs(A),
        right=A,
        hyps=[ZERO < A],
    ),
    lean_rule(
        label="abs_of_nonpos",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a : α}, a ≤ 0 → abs a = -a",
        # implicit_vars=[A],
        left=abs(A),
        right=-A,
        hyps=[A <= ZERO],
    ),
    lean_rule(
        label="abs_of_neg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a : α}, a < 0 → abs a = -a",
        # implicit_vars=[A],
        left=abs(A),
        right=-A,
        hyps=[A < ZERO],
    ),
    lean_rule(
        label="abs_zero",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α], abs 0 = 0",
        left=abs(ZERO),
        right=ZERO,
    ),
    lean_rule(
        label="abs_neg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a : α), abs (-a) = abs a",
        left=abs((-A)),
        right=abs(A),
    ),
    lean_rule(
        label="abs_pos",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a : α}, 0 < abs a ↔ a ≠ 0",
        # implicit_vars=[A],
        left=ZERO < abs(A),
        right=A != ZERO,
    ),
    lean_rule(
        label="abs_pos_of_pos",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a : α}, 0 < a → 0 < abs a",
        # implicit_vars=[A],
        node=ZERO < abs(A),
        hyps=[ZERO < A],
    ),
    lean_rule(
        label="abs_pos_of_neg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a : α}, a < 0 → 0 < abs a",
        # implicit_vars=[A],
        node=ZERO < abs(A),
        hyps=[A < ZERO],
    ),
    lean_rule(
        label="abs_sub_comm",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b : α), abs (a - b) = abs (b - a)",
        left=abs(A - B),
        right=abs(B - A),
    ),
    lean_rule(
        label="neg_le_of_abs_le",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b : α}, abs a ≤ b → -b ≤ a",
        # implicit_vars=[A, B],
        node=-B <= A,
        hyps=[abs(A) <= B],
    ),
    lean_rule(
        label="le_of_abs_le",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b : α}, abs a ≤ b → a ≤ b",
        # implicit_vars=[A, B],
        node=A <= B,
        hyps=[abs(A) <= B],
    ),
    lean_rule(
        label="le_abs_self",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a : α), a ≤ abs a",
        node=A <= abs(A),
    ),
    lean_rule(
        label="neg_le_abs_self",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a : α), -a ≤ abs a",
        node=-A <= abs(A),
    ),
    lean_rule(
        label="neg_abs_le_self",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a : α), -abs a ≤ a",
        node=-abs(A) <= A,
    ),
    lean_rule(
        label="abs_nonneg",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a : α), 0 ≤ abs a",
        node=ZERO <= abs(A),
    ),
    lean_rule(
        label="abs_abs",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a : α), abs (abs a) = abs a",
        left=abs(abs(A)),
        right=abs(A),
    ),
    lean_rule(
        label="abs_eq_zero",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a : α}, abs a = 0 ↔ a = 0",
        # implicit_vars=[A],
        left=abs(A) == ZERO,
        right=A == ZERO,
    ),
    lean_rule(
        label="abs_nonpos_iff",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a : α}, abs a ≤ 0 ↔ a = 0",
        # implicit_vars=[A],
        left=abs(A) <= ZERO,
        right=A == ZERO,
    ),
    lean_rule(
        label="neg_lt_of_abs_lt",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b : α}, abs a < b → -b < a",
        # implicit_vars=[A, B],
        node=-B < A,
        hyps=[abs(A) < B],
    ),
    lean_rule(
        label="lt_of_abs_lt",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b : α}, abs a < b → a < b",
        # implicit_vars=[A, B],
        node=A < B,
        hyps=[abs(A) < B],
    ),
    lean_rule(
        label="max_sub_min_eq_abs'",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b : α), max a b - min a b = abs (a - b)",
        left=Max(A, B) - Min(A, B),
        right=abs(A - B),
    ),
    lean_rule(
        label="max_sub_min_eq_abs",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b : α), max a b - min a b = abs (b - a)",
        left=Max(A, B) - Min(A, B),
        right=abs(B - A),
    ),
    lean_rule(
        label="abs_add",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b : α), abs (a + b) ≤ abs a + abs b",
        node=abs(A + B) <= abs(A) + abs(B),
    ),
    lean_rule(
        label="abs_sub",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b : α), abs (a - b) ≤ abs a + abs b",
        node=abs(A - B) <= abs(A) + abs(B),
    ),
    lean_rule(
        label="abs_sub_abs_le_abs_sub",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b : α), abs a - abs b ≤ abs (a - b)",
        node=abs(A) - abs(B) <= abs(A - B),
    ),
    lean_rule(
        label="abs_le_max_abs_abs",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b c : α}, a ≤ b → b ≤ c → abs b ≤ max (abs a) (abs c)",
        # implicit_vars=[A, B, C],
        node=abs(B) <= Max((abs(A)), (abs(C))),
        hyps=[A <= B, B <= C],
    ),
    lean_rule(
        label="abs_le_abs",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b : α}, a ≤ b → -a ≤ b → abs a ≤ abs b",
        # implicit_vars=[A, B],
        node=abs(A) <= abs(B),
        hyps=[A <= B, -A <= B],
    ),
    lean_rule(
        label="abs_max_sub_max_le_abs",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b c : α), abs (max a c - max b c) ≤ abs (a - b)",
        node=abs(Max(A, C) - Max(B, C)) <= abs(A - B),
    ),
    lean_rule(
        label="eq_of_abs_sub_eq_zero",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b : α}, abs (a - b) = 0 → a = b",
        # implicit_vars=[A, B],
        left=A,
        right=B,
        hyps=[abs(A - B) == ZERO],
    ),
    lean_rule(
        label="abs_sub_le",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b c : α), abs (a - c) ≤ abs (a - b) + abs (b - c)",
        node=abs(A - C) <= abs(A - B) + abs(B - C),
    ),
    lean_rule(
        label="abs_add_three",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] (a b c : α), abs (a + b + c) ≤ abs a + abs b + abs c",
        node=abs(A + B + C) <= abs(A) + abs(B) + abs(C),
    ),
    lean_rule(
        label="dist_bdd_within_interval",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b lb ub : α}, lb ≤ a → a ≤ ub → lb ≤ b → b ≤ ub → abs (a - b) ≤ ub - lb",
        # implicit_vars=[A, B, C, D],
        node=abs(A - B) <= D - C,
        hyps=[C <= A, A <= D, C <= B, B <= D],
    ),
    lean_rule(
        label="eq_of_abs_sub_nonpos",
        statement="∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b : α}, abs (a - b) ≤ 0 → a = b",
        # implicit_vars=[A, B],
        left=A,
        right=B,
        hyps=[abs(A - B) <= 0],
    ),
    lean_rule(
        label="sub_le_self",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] (a : α) {b : α}, 0 ≤ b → a - b ≤ a",
        # implicit_vars=[B],
        node=A - B <= A,
        hyps=[ZERO <= B],
    ),
    lean_rule(
        label="sub_lt_self",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] (a : α) {b : α}, 0 < b → a - b < a",
        # implicit_vars=[B],
        node=A - B < A,
        hyps=[ZERO < B],
    ),
    lean_rule(
        label="le_of_sub_nonneg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, 0 ≤ a - b → b ≤ a",
        # implicit_vars=[A, B],
        node=B <= A,
        hyps=[ZERO <= A - B],
    ),
    lean_rule(
        label="sub_nonneg_of_le",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, b ≤ a → 0 ≤ a - b",
        # implicit_vars=[A, B],
        node=ZERO <= A - B,
        hyps=[B <= A],
    ),
    lean_rule(
        label="sub_nonpos_of_le",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a ≤ b → a - b ≤ 0",
        # implicit_vars=[A, B],
        node=A - B <= ZERO,
        hyps=[A <= B],
    ),
    lean_rule(
        label="le_of_sub_nonpos",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a - b ≤ 0 → a ≤ b",
        # implicit_vars=[A, B],
        node=A <= B,
        hyps=[A - B <= ZERO],
    ),
    lean_rule(
        label="lt_of_sub_pos",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, 0 < a - b → b < a",
        # implicit_vars=[A, B],
        node=B < A,
        hyps=[ZERO < A - B],
    ),
    lean_rule(
        label="sub_pos_of_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, b < a → 0 < a - b",
        # implicit_vars=[A, B],
        node=ZERO < A - B,
        hyps=[B < A],
    ),
    lean_rule(
        label="lt_of_sub_neg",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a - b < 0 → a < b",
        # implicit_vars=[A, B],
        node=A < B,
        hyps=[A - B < ZERO],
    ),
    lean_rule(
        label="sub_neg_of_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b : α}, a < b → a - b < 0",
        # implicit_vars=[A, B],
        node=A - B < ZERO,
        hyps=[A < B],
    ),
    lean_rule(
        label="add_le_of_le_sub_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a ≤ c - b → a + b ≤ c",
        # implicit_vars=[A, B, C],
        node=A + B <= C,
        hyps=[A <= C - B],
    ),
    lean_rule(
        label="le_sub_right_of_add_le",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a + b ≤ c → a ≤ c - b",
        # implicit_vars=[A, B, C],
        node=A <= C - B,
        hyps=[A + B <= C],
    ),
    lean_rule(
        label="add_le_of_le_sub_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, b ≤ c - a → a + b ≤ c",
        # implicit_vars=[A, B, C],
        node=A + B <= C,
        hyps=[B <= C - A],
    ),
    lean_rule(
        label="le_sub_left_of_add_le",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a + b ≤ c → b ≤ c - a",
        # implicit_vars=[A, B, C],
        node=B <= C - A,
        hyps=[A + B <= C],
    ),
    lean_rule(
        label="add_lt_of_lt_sub_left",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, b < c - a → a + b < c",
        # implicit_vars=[A, B, C],
        node=A + B < C,
        hyps=[B < C - A],
    ),
    lean_rule(
        label="lt_sub_left_of_add_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a + b < c → b < c - a",
        # implicit_vars=[A, B, C],
        node=B < C - A,
        hyps=[A + B < C],
    ),
    lean_rule(
        label="add_lt_of_lt_sub_right",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a < c - b → a + b < c",
        # implicit_vars=[A, B, C],
        node=A + B < C,
        hyps=[A < C - B],
    ),
    lean_rule(
        label="lt_sub_right_of_add_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a + b < c → a < c - b",
        # implicit_vars=[A, B, C],
        node=A < C - B,
        hyps=[A + B < C],
    ),
    lean_rule(
        label="sub_left_lt_of_lt_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a < b + c → a - b < c",
        # implicit_vars=[A, B, C],
        node=A - B < C,
        hyps=[A < B + C],
    ),
    lean_rule(
        label="lt_add_of_sub_left_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a - b < c → a < b + c",
        # implicit_vars=[A, B, C],
        node=A < B + C,
        hyps=[A - B < C],
    ),
    lean_rule(
        label="lt_add_of_sub_right_lt",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a - c < b → a < b + c",
        # implicit_vars=[A, B, C],
        node=A < B + C,
        hyps=[A - C < B],
    ),
    lean_rule(
        label="sub_right_lt_of_lt_add",
        statement="∀ {α : Type u} [_inst_1 : ordered_add_comm_group α] {a b c : α}, a < b + c → a - c < b",
        # implicit_vars=[A, B, C],
        node=A - C < B,
        hyps=[A < B + C],
    ),
]

LEAN_MONOID_RULES = [
    lean_rule(
        label="add_lt_add_left",
        statement="∀ {α : Type u_1} [_inst_1 : has_add α] [_inst_2 : has_lt α] [_inst_3 : covariant_class α α has_add.add has_lt.lt] {b c : α}, b < c → ∀ (a : α), a + b < a + c",
        # implicit_vars=[A, B],
        node=C + A < C + B,
        hyps=[A < B],
        # hyp_first=True,
    ),
]

LEAN_CUSTOM_RULES: List[LeanRule] = [
    # custom rule to allow for hypotheses rewrites
    lean_rule(
        label="LEAN__IDENTITY",
        statement="∀ (x y : ℝ), x = y → x = y",
        left=A,
        right=B,
        hyps=[A == B],
    ),
]
# fmt: on


RULES_T: List[TRule] = []
RULES_A: List[ARule] = []

rule_labels: Set[str] = set()
rule_statements: Set[str] = set()

LEAN_GROUPS_RULES = (
    LEAN_GROUPS_RULES + LEAN_GROUPS_WITH_ZERO_RULES + LEAN_ORDERED_GROUP_RULES
)
LEAN_ORDER_RULES = LEAN_ORDER_RULES + LEAN_ORDER_FUNCTIONS_RULES

LEAN_RULES: List[
    LeanRule
] = LEAN_REAL_RULES + LEAN_RING_RULES + LEAN_GROUPS_RULES + LEAN_ORDER_RULES + LEAN_MISC_RULES + LEAN_MONOID_RULES + LEAN_CUSTOM_RULES

LEAN_RULES_WITH_TYPES: List[Tuple[str, List[LeanRule]]] = [
    ("real", LEAN_REAL_RULES),
    ("ring", LEAN_RING_RULES),
    ("group", LEAN_GROUPS_RULES),
    ("order", LEAN_ORDER_RULES),
    ("misc", LEAN_MISC_RULES),
    ("monoid", LEAN_MONOID_RULES),
    ("custom", LEAN_CUSTOM_RULES),
]

for _, rules in LEAN_RULES_WITH_TYPES:

    for rule in rules:

        # check duplicates
        assert rule.label not in rule_labels, rule.label
        # assert rule.statement not in rule_statements, rule.statement
        rule_labels.add(rule.label)
        rule_statements.add(rule.statement)

        # transformation rule
        if rule.is_t_rule:
            assert rule.left is not None
            assert rule.right is not None
            t_rule_ = TRule(
                left=rule.left,
                right=rule.right,
                hyps=rule.hyps,
                rule_type="lean",
                lean_rule=rule,
            )
            RULES_T.append(t_rule_)

        # assertion rule
        else:
            assert rule.node is not None
            a_rule_ = ARule(
                node=rule.node, hyps=rule.hyps, rule_type="lean", lean_rule=rule
            )
            RULES_A.append(a_rule_)

assert len(RULES_T) + len(RULES_A) == len(LEAN_RULES)

RULES_T_E = [rule for rule in RULES_T if not rule.left.is_comp()]
RULES_T_C = [rule for rule in RULES_T if rule.left.is_comp()]
RULES: List[Union[TRule, ARule]] = [*RULES_T, *RULES_A]


def _check_lean_statements(rules: List[LeanRule], auto_fix: bool = False):

    print("===== RUNNING CHECK LEAN STATEMENTS")

    theorems, _ = reload_lean_theorems()
    print(f"Reloaded {len(theorems)} Lean statements.")

    valid = 0
    not_found: List[str] = []
    diff_type: List[str] = []

    for rule in rules:
        if rule.label not in theorems:
            not_found.append(rule.label)
            continue
        if theorems[rule.label] != rule.statement:
            diff_type.append(rule.label)
        else:
            valid += 1

    assert len(rules) == valid + len(not_found) + len(diff_type)

    print(f"Checked {valid}/{len(rules)} Lean rules.")
    if len(not_found):
        print(
            f"{len(not_found)} were not in the initial theorems:", ", ".join(not_found)
        )
    if len(diff_type):
        print(f"{len(diff_type)} had different statements:", ", ".join(diff_type))

    # automatic correction of file
    # cp evariste/envs/equations_rules_lean.py xxx
    # python -m evariste.envs.eq.rules_lean
    # cp yyy evariste/envs/equations_rules_lean.py
    if auto_fix:
        with open("/formal/xxx", "r") as f:
            lines = [line.rstrip() for line in f]
        with open("/Evariste/formal/yyy", "w") as f:
            for i, line in enumerate(lines[:-2]):
                f.write(line + "\n")
                if not (
                    line.strip().startswith("LeanRule(")
                    and lines[i + 1].strip().startswith('label="')
                    and lines[i + 2].strip().startswith('statement="')
                ):
                    continue
                x = lines[i + 1].strip()[len("label=") :]
                y = lines[i + 2].strip()[len("statement=") :]
                assert x[0] == '"', x
                assert y[0] == '"', y
                assert x[-2:] == '",', x
                assert y[-2:] == '",', y
                label = x[1:-2]
                statement = y[1:-2]
                assert len(label) > 0 and label in theorems, label
                if theorems[label] != statement:
                    assert '"' not in theorems[label]
                    f.write(f'        FIXED_STATEMENT="{theorems[label]}",' + "\n")

    print("OK")


if __name__ == "__main__":

    print(
        f"Found: "
        f"{len(RULES):>3} rules / "
        f"{len(RULES_T):>3} T rules / "
        f"{len(RULES_T_E):>3} T-E rules / "
        f"{len(RULES_T_C):>3} T-C rules / "
        f"{len(RULES_A):>3} A rules"
    )

    test_duplicated_rules(RULES, allow_sym=False)
    _check_lean_statements(LEAN_RULES, auto_fix=False)
    # test_valid_transform_rules_e_numeric(RULES_T_E, allow_none=True)
    # test_valid_transform_rules_c_numeric(RULES_T_C, allow_none=True)
    # test_valid_assert_rules_numeric(RULES_A, allow_none=True)
