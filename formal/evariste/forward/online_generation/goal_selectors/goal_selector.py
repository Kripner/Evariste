# Copyright (c) 2019-present, Facebook, Inc.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.
#

from numpy.random.mtrand import RandomState
from abc import ABC, abstractmethod
from dataclasses import dataclass
from logging import getLogger
from typing import List, Dict
import copy
import logging
import numpy as np


from params import Params
from evariste.envs.mm.env import MetamathEnv
from evariste.envs.mm.utils import get_canonical_order
from evariste.forward.common import ForwardGoal, GenerationHistory
from evariste.utils import find_descendents


logger = getLogger()


@dataclass
class GoalSelectionConfig(Params):
    # supervised goal selector
    use_subgoals: bool = False
    use_forbidden: bool = True
    # include human goals in goals
    use_human_dataset: bool = True
    # use_other_split: if "valid" or "minif2f_valid",
    # we sample goals (statements) from this split
    # with a proba of 0.5
    use_other_split: str = ""
    # to load additional goals (like goals generated by LM)
    add_goal_path: str = ""

    # online generated goal selector
    select_generated_goals: bool = False
    max_generated_goals: int = 2_500_000
    generated_goals_sampling_strategy: str = "size"
    generated_goals_sampling_alpha: float = 1.0

    def __post_init__(self):
        strategies = {
            "uniform",
            "size",
            "visited",
            "proof_visited_score",
        }
        assert (
            self.generated_goals_sampling_strategy in strategies
        ), f"{self.generated_goals_sampling_strategy} not in {strategies}"

        if self.use_other_split:
            assert self.use_other_split in ["valid", "minif2f_valid"]
            assert self.use_human_dataset
            assert self.use_forbidden
            assert not self.use_subgoals
            assert not self.select_generated_goals


class EmptySelector(Exception):
    pass


@dataclass
class GoalMetadata:
    generation_id: int
    node_id: int
    depth: int
    size: int
    label: str
    proof_visited_score: float = -1


@dataclass
class GoalStats:
    min_size: int
    min_depth: int
    n_selected: int = 0
    # once it is returned by prover we can increment this column
    n_updated: int = 0
    n_proved: int = 0
    n_generated: int = 0
    proof_visited_score: float = -1


@dataclass
class _Infos:
    time_in_dumping: int = 0
    n_interesting: int = 0


class GoalSelector(ABC):
    @abstractmethod
    def select_goal(self) -> ForwardGoal:
        pass

    @abstractmethod
    def update_with_generation(
        self, generation_id: int, generated: GenerationHistory, solved: bool
    ):
        pass

    @abstractmethod
    def state_dict(self) -> Dict:
        pass

    @abstractmethod
    def load_state_dict(self, state_dict: Dict):
        pass

    @property
    @abstractmethod
    def stats(self):
        pass

    @abstractmethod
    def update_state(self):
        pass


class UniformGoalSelector(GoalSelector):
    def __init__(self, seed: int, goals: List[ForwardGoal]):
        self.goals = goals
        self.waiting = {}
        self.rng = RandomState(seed)
        self.infos = _Infos()

    def select_goal(self) -> ForwardGoal:
        if len(self.goals) == 0:
            raise EmptySelector
        idx = self.rng.randint(0, len(self.goals))
        goal = copy.deepcopy(self.goals[idx])
        e_hyps = goal.e_hyps
        self.rng.shuffle(e_hyps)
        return goal

    def update_with_generation(
        self, generation_id: int, generated: GenerationHistory, solved: bool
    ):
        pass

    @classmethod
    def from_supervised_dataset(
        cls,
        world_size: int,
        rank: int,
        mm_data_dir: str,
        database_path: str,
        split: str,
        seed: int,
        use_forbidden: bool = True,
        use_subgoals: bool = False,
    ) -> "UniformGoalSelector":
        from evariste.forward.fwd_mm.mm_helpers import (
            load_splitted_proof_trees,
            get_mand_disj,
        )

        data = load_splitted_proof_trees(mm_data_dir)[split]
        data = [s for i, s in enumerate(data) if i % world_size == rank]
        logger.info(f"N proofs: {len(data)}")
        goals = []

        forbiddens = {}
        if use_forbidden:
            logger.info("Loading mm_env")
            mm_env = MetamathEnv(
                filepath=database_path,
                start_label="",
                stop_label="",
                rename_e_hyps=True,
                decompress_proofs=True,
                verify_proofs=False,
                log_level="info",
            )
            mm_env.process()
            logger.info("Computing forbidden")
            dag = mm_env.parse_label_dag()
            for name, _ in data:
                forbidden = set(find_descendents(dag, name))
                assert len(forbidden) > 0, name
                forbiddens[name] = forbidden

        logger.info("Extracting goals from proofs")
        for trm_name, root in data:
            if use_subgoals:
                nodes = get_canonical_order(root)
            else:
                nodes = [root]
            for node in nodes:
                if node.ltype == "$e":
                    continue
                if use_forbidden:
                    forbidden = forbiddens[trm_name]
                else:
                    forbidden = None
                e_hyps = list(node.e_hyps.values())
                new_goal = ForwardGoal(
                    statement=node.statement_str,
                    e_hyps=e_hyps,
                    forbidden=forbidden,
                    label=trm_name,
                    mand_disj=get_mand_disj(
                        statement=node.statement_str,
                        e_hyps=node.e_hyps,
                        disjoints=node.disjoint,
                    ),
                )
                goals.append(new_goal)
        selector = cls(seed=seed, goals=goals)
        logging.info(f"Selector init with {len(selector.goals)} goals")
        return selector

    def update_state(self):
        pass

    def load_state_dict(self, state_dict: Dict):
        assert state_dict == {}

    def state_dict(self) -> Dict:
        return {}

    @property
    def stats(self):
        return {"n_goals": len(self.goals)}


class GeneratedGoalSelector(GoalSelector):
    def __init__(
        self,
        max_goals: int,
        seed: int,
        sampling_strategy: str = "uniform",
        alpha: float = 1.0,
    ):
        # TODO save space by removing forbidden
        self.rng = RandomState(seed)
        self.strategy = sampling_strategy
        self.alpha = alpha
        self.infos = _Infos()

        # not a list but ok...
        self.max_goals = max_goals
        self.goals: List[ForwardGoal] = []
        self.goal_stats: List[GoalStats] = []
        self.weight_cumulative: np.array = np.array([])
        self.reversed_index = {}

        self.new_goals: List[ForwardGoal] = []
        self.new_metadata: List[GoalMetadata] = []

        self.forbiddens = {}

    def select_goal(self) -> ForwardGoal:
        assert len(self.goals) == len(self.goal_stats) == len(self.reversed_index)
        if len(self.goals) == 0:
            raise EmptySelector
        assert len(self.goals) == len(self.weight_cumulative)
        index = np.searchsorted(
            self.weight_cumulative,  # a
            self.rng.random() * self.weight_cumulative[-1],  # v
            side="right",  # a[i-1] <= v < a[i]
        )
        goal = copy.deepcopy(self.goals[index])
        assert goal.label is not None
        goal.forbidden = self.forbiddens[goal.label]
        self.goal_stats[index].n_selected += 1
        e_hyps = goal.e_hyps
        self.rng.shuffle(e_hyps)
        return goal

    def update_with_generation(
        self, generation_id: int, generated: GenerationHistory, solved: bool
    ):
        assert len(self.goals) == len(self.goal_stats) == len(self.reversed_index)
        received_goal = generated.goal
        label = received_goal.label

        if label not in self.forbiddens:
            self.forbiddens[label] = received_goal.forbidden

        # Update goal stats
        key = self.goal_key(received_goal)
        if key in self.reversed_index:
            local_id = self.reversed_index[key]
            self.goal_stats[local_id].n_updated += 1
            self.goal_stats[local_id].n_proved += int(solved)

        from evariste.forward.fwd_mm.mm_helpers import (
            history_to_mm_nodes,
            get_mand_disj,
        )

        for node_id, node in enumerate(history_to_mm_nodes(generated)):
            if node.ltype == "$e":
                continue
            node.set_nodes_and_depth()
            depth = node.depth["no_syntactic"]
            order = [n for n in get_canonical_order(node) if n.ltype != "$e"]
            size = len(order)

            proof_visited_score = 0
            for n in order:
                if n.statement_str in self.reversed_index:
                    local_id = self.reversed_index[n.statement_str]
                    prev_visited = self.goal_stats[local_id].n_generated
                else:
                    prev_visited = 0
                proof_visited_score += 1.0 / (1 + prev_visited)

            e_hyps = list(node.e_hyps.values())

            new_goal = ForwardGoal(
                statement=node.statement_str,
                e_hyps=e_hyps,
                forbidden=set(),  # stored in self.forbiddens
                mand_disj=get_mand_disj(
                    statement=node.statement_str,
                    e_hyps=node.e_hyps,
                    disjoints=node.disjoint,
                ),
                label=label,
                thm=None,
            )
            new_metadata = GoalMetadata(
                generation_id=generation_id,
                node_id=node_id,
                depth=depth,
                size=size,
                proof_visited_score=proof_visited_score,
                label=label,
            )

            self.new_goals.append(new_goal)
            self.new_metadata.append(new_metadata)

    def update_state(self):
        assert len(self.new_goals) == len(self.new_metadata)
        for goal, metadata in zip(self.new_goals, self.new_metadata):
            assert goal.label is not None
            assert goal.label in self.forbiddens
            assert isinstance(metadata, GoalMetadata)
            key = self.goal_key(goal)
            if key in self.reversed_index:
                local_id = self.reversed_index[key]
                stats = self.goal_stats[local_id]
                stats.n_generated += 1
                if metadata.size < stats.min_size:
                    stats.min_size = metadata.size
                if metadata.depth < stats.min_depth:
                    stats.min_depth = metadata.depth
                if metadata.proof_visited_score < stats.proof_visited_score:
                    stats.proof_visited_score = metadata.proof_visited_score
            else:
                local_id = len(self.goals)
                self.goals.append(goal)
                self.reversed_index[key] = local_id
                new_stats = GoalStats(
                    min_depth=metadata.depth,
                    min_size=metadata.size,
                    n_generated=1,
                    proof_visited_score=metadata.proof_visited_score,
                )
                self.goal_stats.append(new_stats)

        self.remove_old_and_build_index_and_cumulative()
        self.new_goals = []
        self.new_metadata = []

    def remove_old_and_build_index_and_cumulative(self):
        self.goals = self.goals[-self.max_goals :]
        self.goal_stats = self.goal_stats[-self.max_goals :]
        assert len(self.goals) == len(self.goal_stats)
        self.reversed_index = {
            self.goal_key(g): idx for idx, g in enumerate(self.goals)
        }
        assert len(self.reversed_index) == len(self.goals)
        self.weight_cumulative = np.cumsum(
            [self.score(s) ** self.alpha for s in self.goal_stats]
        )

    def score(self, stats: GoalStats) -> float:
        if self.strategy == "uniform":
            return 1.0
        elif self.strategy == "visited":
            return 1.0 / stats.n_generated
        elif self.strategy == "size":
            return stats.min_size
        elif self.strategy == "proof_visited_score":
            return stats.proof_visited_score
        else:
            raise NotImplementedError

    @staticmethod
    def goal_key(goal: ForwardGoal):
        return (
            goal.statement
        )  # deduplicate on goal statement for the moment, collisions are ok
        # return tuple(
        #     [
        #         goal.statement,
        #         tuple(sorted(goal.e_hyps)),
        #         tuple(sorted(goal.mand_disj)),
        #         None
        #         if goal.forbidden is None
        #         else goal.label,  # we don't want to store forbidden in the key
        #     ]
        # )

    def state_dict(self) -> Dict:
        # check if it's in 'clean' state
        assert not self.new_metadata
        assert not self.new_goals
        return {
            "goals": self.goals,
            "goal_stats": self.goal_stats,
            "forbiddens": self.forbiddens,
        }

    def load_state_dict(self, state_dict: Dict):
        assert not self.new_metadata
        assert not self.new_goals
        self.goals = state_dict["goals"]
        self.goal_stats = state_dict["goal_stats"]
        self.forbiddens = state_dict["forbiddens"]
        assert isinstance(self.goals, list)
        assert isinstance(self.goal_stats, list)
        for g in self.goals:
            assert isinstance(g, ForwardGoal)
            assert g.label in self.forbiddens
        self.remove_old_and_build_index_and_cumulative()

    @property
    def stats(self):
        scores = np.array([self.score(s) for s in self.goal_stats])
        assert len(scores) == len(self.goals)
        if self.goals:
            q = [0, 25, 50, 75, 90, 95, 100]
            percentiles = np.percentile(scores, q)
            mean_ = np.mean(scores)
        else:
            q = []
            percentiles = []
            mean_ = -1
        return {
            "n_goals": len(self.goals),
            "mean_score": mean_,
            "percentiles": {qq: p for qq, p in zip(q, percentiles)},
        }


class MixedGoalSelector(GoalSelector):
    def __init__(
        self,
        supervised: UniformGoalSelector,
        generated: GeneratedGoalSelector,
        seed: int,
    ):
        self.supervised = supervised
        self.generated = generated
        self.rng = RandomState(seed)

    def select_goal(self) -> ForwardGoal:
        if self.rng.random() < 0.5:
            return self.supervised.select_goal()
        else:
            try:
                return self.generated.select_goal()
            except EmptySelector:
                return self.supervised.select_goal()

    def update_with_generation(
        self, generation_id: int, generated: GenerationHistory, solved: bool
    ):
        # we don't update supervised selector
        self.generated.update_with_generation(generation_id, generated, solved)

    def state_dict(self) -> Dict:
        return {
            "supervised": self.supervised.state_dict(),
            "generated": self.generated.state_dict(),
        }

    def load_state_dict(self, state_dict: Dict):
        self.supervised.load_state_dict(state_dict["supervised"])
        self.generated.load_state_dict(state_dict["generated"])

    def update_state(self):
        self.supervised.update_state()
        self.generated.update_state()

    @property
    def stats(self):
        stats = {}
        stats.update({f"supervised.{k}": v for k, v in self.supervised.stats.items()})
        stats.update({f"generated.{k}": v for k, v in self.generated.stats.items()})
        return stats


class MultiGoalSelector(GoalSelector):
    def __init__(
        self, selectors: List[UniformGoalSelector], seed: int,
    ):
        self.selectors = selectors
        self.rng = RandomState(seed)

    def select_goal(self) -> ForwardGoal:
        id_ = self.rng.randint(len(self.selectors))
        return self.selectors[id_].select_goal()

    def update_with_generation(
        self, generation_id: int, generated: GenerationHistory, solved: bool
    ):
        # we don't update supervised selectors
        pass

    def state_dict(self) -> Dict:
        return {}

    def load_state_dict(self, state_dict: Dict):
        pass

    def update_state(self):
        pass

    @property
    def stats(self):
        stats = {}
        for i, selector in enumerate(self.selectors):
            stats.update({f"selector{i}.{k}": v for k, v in selector.stats.items()})
        return stats
