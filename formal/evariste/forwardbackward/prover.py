# Copyright (c) 2019-present, Facebook, Inc.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.
#

import logging
from typing import List, Dict, Type, Union, Set, Iterator
from evariste.backward.env.metamath import MMTheorem
from evariste.backward.prover.igreedy_prover import (
    ImprovedGreedyGoal,
    ProofResultsWithProofHandler,
)
from evariste.datasets import DatasetConf
from evariste.forward.fwd_mm.mm_helpers import history_to_mm_nodes

from evariste.model.transformer_args import DecodingParams
from params.params import Params

from evariste.forward.cli.prove import Config

from evariste.forward.common import ForwardGoal, GenerationHistory
from evariste.backward.env.core import BackwardGoal, EnvGen
from evariste.backward.prover.prover import (
    ProverParams,
    ProofHandler,
    ProofHandlerFailure,
)
from evariste.backward.graph import Proof, Theorem, Tactic, Tuple, Optional

import torch

from evariste.forwardbackward.forward_client import ForwardClient
from evariste.forwardbackward.backward_client import BackwardClient

# Some rebinding to be more readable
BackwardProverParams = ProverParams
ForwardProverParams = Config


class FBProverParams(Params):
    backward_params: BackwardProverParams
    backward_decoding: DecodingParams
    forward_params: ForwardProverParams
    datasetconf: DatasetConf
    backward_proofhandler: type(ProofHandler)


def history_to_mmthm(history: GenerationHistory) -> Set[Theorem]:
    """
    Get a GenerationHistory from the forward generator and produces true Theorems
    @param history:
    @return:
    """

    nodes = history_to_mm_nodes(history)
    theorems: Set[MMTheorem] = set()
    for node in nodes:

        thm = MMTheorem(
            conclusion=node.statement_str,
            hyps=[(None, h) for h in history.goal.e_hyps],
        )
        theorems.add(thm)

    return theorems


def history_to_mmconclusion(history: GenerationHistory) -> Set[str]:
    """
    Extract only the conclusion statement from the generation history. Will be removed in the future and replace
    by history_to_mmthm
    @param history:
    @return:
    """
    nodes = history_to_mm_nodes(history)
    conclusions: Set[str] = set()
    for node in nodes:
        conclusions.add(node.statement_str)

    return conclusions


def fwdgoal2bwdgoal(goal: ForwardGoal) -> ImprovedGreedyGoal:
    """
    Convert a ForwardGoal to a BackwardGoal
    @param goal:
    @return:
    """
    thm = Theorem(goal.statement, [(None, hyp) for hyp in goal.e_hyps])
    return ImprovedGreedyGoal(thm, name="")


def bwdgoal2fwdgoal(goal: BackwardGoal) -> ForwardGoal:
    """
    Converts a BackwardGoal into a ForwardGoal
    @param goal:
    @return:
    """
    return ForwardGoal(
        goal.theorem.conclusion, e_hyps=[h for _, h in goal.theorem.hyps]
    )


class FBProver:
    def __init__(self, params: FBProverParams):
        """
        Initializes the BackwardCleint and the Forwardclient
        @param params:
        """

        self.params = params
        self.backward_client = BackwardClient(
            dataset=params.datasetconf,
            decoder_type="decoder",
            prover=params.backward_params,
            decoding=params.backward_decoding,
            proof_handler=params.backward_proofhandler,
        )

        self.forward_client = ForwardClient(params.forward_params)

    def init_bwd_proof(self, goal: BackwardGoal) -> ProofHandler:
        """
        Buil a ProofHandler from a goal using the proofhandler passed to the prover.
        @param goal: BackwardGoal
        @return:
        """
        return self.params.backward_proofhandler(goal)

    def sync_prove(
        self, goals: List[BackwardGoal], trials=128, nsteps=5, fwdsteps=1
    ) -> List[ProofHandler]:
        """
        Do sync_step(s). A step is the combination of fwdsteps steps of forward on each leaf of the proof tree
        and then a complete run of the backward prover.
        A trial is doing nsteps steps of what stated above.
        The new hypothesises generated by the forward are kept from one trial to the next as a constantly growing
        database of usable true results. However the proofhandler is reset to only the goal.
        @param goals: List of goals to prove
        @param trials: number of trials to make.
        @param nsteps: number of steps on the same proof tree to do.
        @param fwdsteps: number of fwd trials to do on each leave.
        @return: a list of proofhandlers in their last state: either proved or not.
        """

        logging.info("Launch fwd-bwd prover.")
        finished = []

        # We initialize all our proof handlers on the provided goals
        proofhandlers = [self.init_bwd_proof(g) for g in goals]

        for t in range(trials):
            # Begining of a trial
            logging.info(f"trial: {t}")

            # Step loop
            for step in range(nsteps):

                logging.info(f"step: {step}")

                # We execute a step
                results: List[ProofResultsWithProofHandler] = self.sync_step(
                    proofhandlers, fwdsteps=fwdsteps
                )

                proofhandlers = []
                for result in results:
                    # If the proofhandler failed for whatever reason we reinitialize it from scratch
                    # but we still give it all the node generated by previous forward steps
                    if result.proofhandler.fail == ProofHandlerFailure.TOO_BIG:
                        newph = self.init_bwd_proof(result.proofhandler.goal)
                        newph.add_hyps(result.proofhandler.additional_hyps)
                        proofhandlers.append(newph)

                    # If the proofhandler is not done ie it does not have found a proof yet
                    # We put it back in the list of proofhandlers to process
                    elif (
                        result.proofhandler.fail
                        == ProofHandlerFailure.TERMINATED_WITHOUT_PROVING
                    ):
                        # In case the proofhandler has some maxsteps to run we set it back to 0
                        result.proofhandler.restart()
                        proofhandlers.append(result.proofhandler)

                    # If we did not fail and got a proof
                    # For debug/stats purpose we print it
                    # And store it into the finished
                    else:
                        print(result.proofhandler)
                        finished.append(result.proofhandler)

            # If it was the last trial we can stop the loop
            if t == trials - 1:
                break

            # Else we reset the proofhandlers which have failed to find a proof
            # And we begin a new trial
            proofhandlers_ = []
            for ph in proofhandlers:
                newph = self.init_bwd_proof(ph.goal)
                newph.add_hyps(ph.additional_hyps)
                proofhandlers_.append(newph)

            proofhandlers = proofhandlers_

        # Before returning we print the proofhandlers that did not find a proof (for debugging and stats purpose)
        for p in proofhandlers:
            print(p)

        # Return the finished one and the failed ones
        return finished + proofhandlers

    def sync_step(
        self, proofhandlers: List[ProofHandler], fwdsteps=1
    ) -> List[ProofResultsWithProofHandler]:
        """
        Execute a step of the alternate fwdbwd.
        It first run the forward on each leave of the backwardproof tree trying to reach the remaining non proven
        subgoals from the hyps.
        We use all the nodes generated by the forward as additional hypothesises for the backward. We then run again
        the backward from that state.

        @param proofhandlers: list of proof handlers to operate on.
        @param fwdsteps: number of fwd steps to do on each leave.
        @return: return a list of proof results containing the proof handler in its state after the step.
        """
        # First we extract from the proof handlers the leaves that the forward prover should try to reach
        # For the first step that leave would be the root ie the main goal
        targets_for_forward: List[List[Theorem]] = [
            ph.to_expand_by_forward() for ph in proofhandlers
        ]

        # We keep for each goal a set of Theorem which will be the additional hyps to add to the proof handler
        additional_hyps: Dict[int, Set[Theorem]] = {
            k: set() for k, _ in enumerate(proofhandlers)
        }

        # We create an idea for each leave of each proofhandler and store to which proofhandler each leaf is linked with
        c = 0
        id2proofhandler: Dict[int, int] = {}
        flatten_targets = []

        # For each proof handler we have a list of leaves
        for k, targets in enumerate(targets_for_forward):
            # For each target for that proofhandler k
            for t in targets:
                # We note that leaf c belongs to proofhandler k
                id2proofhandler[c] = k
                # We store a flatten list of target for the forward prover
                flatten_targets.append(t)
                # next id
                c += 1

        # Fwd input iterator (over the flatten targets)
        def fwd_input() -> Iterator[Tuple[int, ForwardGoal]]:
            for k, g in enumerate(flatten_targets):
                yield k, ForwardGoal(g.conclusion, [h for _, h in g.hyps])

        logging.info("Using forward to generate true hyps.")
        # We potentially run the fwd prover several time on each leaf
        for step in range(fwdsteps):
            for (k, proofsearch,) in self.forward_client.forwardprover.generate_proofs(
                fwd_input()
            ):
                # We store the union of each pass
                # k is here the id of the leaf, we use the dict we built to find the proofhandler it belongs to
                additional_hyps[id2proofhandler[k]] |= history_to_mmthm(
                    proofsearch.generation
                )

        # Trick to allow the forward and the backward to live together
        torch.cuda.empty_cache()

        # We can now add the additional hyps to the proofhandlers
        # it takes care of checking if some of them reached the leaves and actually proved things
        for k, ph in enumerate(proofhandlers):
            ph.add_hyps(additional_hyps[k])

        # Backward input iterator
        def bwd_input() -> Iterator[ProofHandler]:
            for k, ph in enumerate(proofhandlers):
                if not ph.done or not ph.fail:
                    yield ph

        logging.info("Proving with backward.")
        results = []
        # We run the backward prover from the last state but with an augmented set of additional hyps
        for proofresult, _, _ in self.backward_client.generate_proofs(bwd_input):
            results.append(proofresult)

        # Trick to allow the forward and the backward to live together
        torch.cuda.empty_cache()

        return results

    def sync_prove_old(self, goals: List[BackwardGoal], nfwd_steps=2, nbwd_steps=2):

        # First we create dict to store the true theorems generated by the forward pass
        # for each goal to prove
        additional_hyps: Dict[int, Set[Theorem]] = {
            k: set() for k, _ in enumerate(goals)
        }

        proven: Set[str] = set()

        print("SYNC PROVE")

        # Input iterator for a forward pass
        def fwd_input() -> Iterator[Tuple[int, ForwardGoal]]:
            for k, g in enumerate(goals):
                # If we proved it in a previous iteration no need to try again
                # save compute power, save the environnement
                if g.theorem.conclusion not in additional_hyps[k]:
                    yield k, bwdgoal2fwdgoal(g)

        print("FOWARD GEN")
        # We call several time the fwd generator on the data to produce a large amount of proved thms
        for step in range(nfwd_steps):
            for (k, proofsearch,) in self.forward_client.forwardprover.generate_proofs(
                fwd_input()
            ):
                additional_hyps[k] |= history_to_mmthm(proofsearch.generation)

        print("BACKWARD GEN")
        results = []

        # Trick to allow the forward and the backward to live together
        torch.cuda.empty_cache()
        proven: Set[Theorem] = set()
        for step in range(nbwd_steps):
            print(f"Trial: {step}")

            # Input iterator for the backward
            def bwd_input() -> Iterator[ImprovedGreedyGoal]:
                for k, g in enumerate(goals):
                    if g.theorem not in proven:
                        yield ImprovedGreedyGoal(
                            g.theorem, name=str(k), hypothesis=additional_hyps[k]
                        )

            for proofresult, _, _ in self.backward_client.generate_proofs_from_goals(
                bwd_input
            ):
                print(proofresult.proofhandler)
                p = proofresult.proofhandler.done and not proofresult.proofhandler.fail
                if p:
                    results.append(proofresult)
                    proven.add(proofresult.proofhandler.goal.theorem)

                if step == nbwd_steps - 1:
                    results.append(proofresult)

        # We return a list of ProofHandler storing the proof trees, additional hyps, goal and everything to be
        # explore afterwards
        return results

    def close(self):
        self.backward_client.close()
